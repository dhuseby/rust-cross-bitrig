diff --git a/configure b/configure
index ea9320c..e8962b4 100755
--- a/configure
+++ b/configure
@@ -368,16 +368,20 @@ case $CFG_OSTYPE in
     FreeBSD)
         CFG_OSTYPE=unknown-freebsd
         ;;
 
     DragonFly)
         CFG_OSTYPE=unknown-dragonfly
         ;;
 
+    Bitrig)
+        CFG_OSTYPE=unknown-bitrig
+        ;;
+
     Darwin)
         CFG_OSTYPE=apple-darwin
         ;;
 
     MINGW*)
         # msys' `uname` does not print gcc configuration, but prints msys
         # configuration. so we cannot believe `uname -m`:
         # msys1 is always i686 and msys2 is always x86_64.
@@ -722,16 +726,23 @@ fi
 
 # Force freebsd to build with clang; gcc doesn't like us there
 if [ $CFG_OSTYPE = unknown-freebsd ]
 then
     step_msg "on FreeBSD, forcing use of clang"
     CFG_ENABLE_CLANG=1
 fi
 
+# Force bitrig to build with clang; gcc doesn't like us there
+if [ $CFG_OSTYPE = unknown-bitrig ]
+then
+    step_msg "on Bitrig, forcing use of clang"
+    CFG_ENABLE_CLANG=1
+fi
+
 if [ -z "$CFG_ENABLE_CLANG" -a -z "$CFG_GCC" ]
 then
     err "either clang or gcc is required"
 fi
 
 # OS X 10.9, gcc is actually clang. This can cause some confusion in the build
 # system, so if we find that gcc is clang, we should just use clang directly.
 if [ $CFG_OSTYPE = apple-darwin -a -z "$CFG_ENABLE_CLANG" ]
@@ -1093,21 +1104,22 @@ then
     "${CFG_GIT}" submodule update --recursive
     need_ok "git failed"
 
     # NB: this is just for the sake of getting the submodule SHA1 values
     # and status written into the build log.
     msg "git: submodule status"
     "${CFG_GIT}" submodule status --recursive
 
-    msg "git: submodule clobber"
-    "${CFG_GIT}" submodule foreach --recursive git clean -dxf
-    need_ok "git failed"
-    "${CFG_GIT}" submodule foreach --recursive git checkout .
-    need_ok "git failed"
+    # don't clobber so that our patches won't get removed
+    #msg "git: submodule clobber"
+    #"${CFG_GIT}" submodule foreach --recursive git clean -dxf
+    #need_ok "git failed"
+    #"${CFG_GIT}" submodule foreach --recursive git checkout .
+    #need_ok "git failed"
 
     cd ${CFG_BUILD_DIR}
 fi
 
 # Configure llvm, only if necessary
 step_msg "looking at LLVM"
 CFG_LLVM_SRC_DIR=${CFG_SRC_DIR}src/llvm/
 for t in $CFG_HOST
diff --git a/mk/cfg/x86_64-unknown-bitrig.mk b/mk/cfg/x86_64-unknown-bitrig.mk
new file mode 100644
index 0000000..ad34988
--- /dev/null
+++ b/mk/cfg/x86_64-unknown-bitrig.mk
@@ -0,0 +1,26 @@
+# x86_64-unknown-bitrig-elf configuration
+CC_x86_64-unknown-bitrig=$(CC)
+CXX_x86_64-unknown-bitrig=$(CXX)
+CPP_x86_64-unknown-bitrig=$(CPP)
+AR_x86_64-unknown-bitrig=$(AR)
+CFG_LIB_NAME_x86_64-unknown-bitrig=lib$(1).so
+CFG_STATIC_LIB_NAME_x86_64-unknown-bitrig=lib$(1).a
+CFG_LIB_GLOB_x86_64-unknown-bitrig=lib$(1)-*.so
+CFG_LIB_DSYM_GLOB_x86_64-unknown-bitrig=$(1)-*.dylib.dSYM
+CFG_JEMALLOC_CFLAGS_x86_64-unknown-bitrig := -m64 -I/usr/include $(CFLAGS)
+CFG_GCCISH_CFLAGS_x86_64-unknown-bitrig := -Wall -Werror -fPIC -m64 -I/usr/include $(CFLAGS)
+CFG_GCCISH_LINK_FLAGS_x86_64-unknown-bitrig := -shared -pic -pthread -m64 $(LDFLAGS)
+CFG_GCCISH_DEF_FLAG_x86_64-unknown-bitrig := -Wl,--export-dynamic,--dynamic-list=
+CFG_GCCISH_PRE_LIB_FLAGS_x86_64-unknown-bitrig := -Wl,-pic -Wl,-whole-archive
+CFG_GCCISH_POST_LIB_FLAGS_x86_64-unknown-bitrig := -Wl,-no-whole-archive
+CFG_DEF_SUFFIX_x86_64-unknown-bitrig := .bsd.def
+CFG_LLC_FLAGS_x86_64-unknown-bitrig :=
+CFG_INSTALL_NAME_x86_64-unknown-bitrig =
+CFG_EXE_SUFFIX_x86_64-unknown-bitrig :=
+CFG_WINDOWSY_x86_64-unknown-bitrig :=
+CFG_UNIXY_x86_64-unknown-bitrig := 1
+CFG_PATH_MUNGE_x86_64-unknown-bitrig :=
+CFG_LDPATH_x86_64-unknown-bitrig :=
+CFG_RUN_x86_64-unknown-bitrig=$(2)
+CFG_RUN_TARG_x86_64-unknown-bitrig=$(call CFG_RUN_x86_64-unknown-bitrig,,$(2))
+CFG_GNU_TRIPLE_x86_64-unknown-bitrig := x86_64-unknown-bitrig
diff --git a/mk/main.mk b/mk/main.mk
index a97e68a..c2d145e 100644
--- a/mk/main.mk
+++ b/mk/main.mk
@@ -394,17 +394,17 @@ CSREQ$(1)_T_$(2)_H_$(3) = \
 ifeq ($(1),0)
 # Don't run the stage0 compiler under valgrind - that ship has sailed
 CFG_VALGRIND_COMPILE$(1) =
 else
 CFG_VALGRIND_COMPILE$(1) = $$(CFG_VALGRIND_COMPILE)
 endif
 
 # Add RUSTFLAGS_STAGEN values to the build command
-EXTRAFLAGS_STAGE$(1) = $$(RUSTFLAGS_STAGE$(1))
+EXTRAFLAGS_STAGE$(1) = --sysroot $$(HROOT$(1)_H_$(3)) $$(RUSTFLAGS_STAGE$(1))
 
 CFGFLAG$(1)_T_$(2)_H_$(3) = stage$(1)
 
 endef
 
 # Same macro/variables as above, but defined in a separate loop so it can use
 # all the variables above for all archs. The RPATH_VAR setup sometimes needs to
 # reach across triples to get things in order.
diff --git a/mk/platform.mk b/mk/platform.mk
index 50bf51b..ecfe451 100644
--- a/mk/platform.mk
+++ b/mk/platform.mk
@@ -139,24 +139,24 @@ ifdef CFG_CCACHE_BASEDIR
   export CCACHE_BASEDIR
 endif
 
 FIND_COMPILER = $(word 1,$(1:ccache=))
 
 define CFG_MAKE_TOOLCHAIN
   # Prepend the tools with their prefix if cross compiling
   ifneq ($(CFG_BUILD),$(1))
-	CC_$(1)=$(CROSS_PREFIX_$(1))$(CC_$(1))
-	CXX_$(1)=$(CROSS_PREFIX_$(1))$(CXX_$(1))
-	CPP_$(1)=$(CROSS_PREFIX_$(1))$(CPP_$(1))
-	AR_$(1)=$(CROSS_PREFIX_$(1))$(AR_$(1))
-	RUSTC_CROSS_FLAGS_$(1)=-C linker=$$(call FIND_COMPILER,$$(CC_$(1))) \
-	    -C ar=$$(call FIND_COMPILER,$$(AR_$(1))) $(RUSTC_CROSS_FLAGS_$(1))
+  CC_$(1)=$(CROSS_PREFIX_$(1))$(CC_$(1))
+  CXX_$(1)=$(CROSS_PREFIX_$(1))$(CXX_$(1))
+  CPP_$(1)=$(CROSS_PREFIX_$(1))$(CPP_$(1))
+  AR_$(1)=$(CROSS_PREFIX_$(1))$(AR_$(1))
+  RUSTC_CROSS_FLAGS_$(1)=-C linker=$$(call FIND_COMPILER,$$(CC_$(1))) \
+      -C ar=$$(call FIND_COMPILER,$$(AR_$(1))) $(RUSTC_CROSS_FLAGS_$(1))
 
-	RUSTC_FLAGS_$(1)=$$(RUSTC_CROSS_FLAGS_$(1)) $(RUSTC_FLAGS_$(1))
+  RUSTC_FLAGS_$(1)=$$(RUSTC_CROSS_FLAGS_$(1)) $(RUSTC_FLAGS_$(1))
   endif
 
   CFG_COMPILE_C_$(1) = $$(CC_$(1)) \
         $$(CFG_GCCISH_CFLAGS) \
         $$(CFG_GCCISH_CFLAGS_$(1)) \
         $$(CFG_DEPEND_FLAGS) \
         -c -o $$(1) $$(2)
   CFG_LINK_C_$(1) = $$(CC_$(1)) \
@@ -174,29 +174,37 @@ define CFG_MAKE_TOOLCHAIN
   CFG_LINK_CXX_$(1) = $$(CXX_$(1)) \
         $$(CFG_GCCISH_LINK_FLAGS) -o $$(1) \
         $$(CFG_GCCISH_LINK_FLAGS_$(1)) \
         $$(CFG_GCCISH_DEF_FLAG_$(1))$$(3) $$(2) \
         $$(call CFG_INSTALL_NAME_$(1),$$(4))
 
   ifeq ($$(findstring $(HOST_$(1)),arm aarch64 mips mipsel),)
 
+  # On Bitrig, we need the relocation model to be PIC for everthing
+  ifeq (,$(filter $(OSTYPE_$(1)),bitrig))
+    LLVM_MC_RELOCATION_MODEL="pic"
+  else
+    LLVM_MC_RELOCATION_MODEL="default"
+  endif
+
   # We're using llvm-mc as our assembler because it supports
   # .cfi pseudo-ops on mac
   CFG_ASSEMBLE_$(1)=$$(CPP_$(1)) -E $$(CFG_DEPEND_FLAGS) $$(2) | \
                     $$(LLVM_MC_$$(CFG_BUILD)) \
                     -assemble \
+                    -relocation-model=$$(LLVM_MC_RELOCATION_MODEL) \
                     -filetype=obj \
                     -triple=$(1) \
                     -o=$$(1)
   else
 
   # For the ARM, AARCH64 and MIPS crosses, use the toolchain assembler
   # FIXME: We should be able to use the LLVM assembler
   CFG_ASSEMBLE_$(1)=$$(CC_$(1)) $$(CFG_GCCISH_CFLAGS_$(1)) \
-		    $$(CFG_DEPEND_FLAGS) $$(2) -c -o $$(1)
+        $$(CFG_DEPEND_FLAGS) $$(2) -c -o $$(1)
 
   endif
 
 endef
 
 $(foreach target,$(CFG_TARGET), \
   $(eval $(call CFG_MAKE_TOOLCHAIN,$(target))))
diff --git a/mk/tests.mk b/mk/tests.mk
index 714a9f8..b5e9ef4 100644
--- a/mk/tests.mk
+++ b/mk/tests.mk
@@ -589,17 +589,17 @@ define DEF_CTEST_VARS
 TEST_SREQ$(1)_T_$(2)_H_$(3) = \
 	$$(HBIN$(1)_H_$(3))/compiletest$$(X_$(3)) \
 	$$(SREQ$(1)_T_$(2)_H_$(3))
 
 # Rules for the cfail/rfail/rpass/bench/perf test runner
 
 # The tests select when to use debug configuration on their own;
 # remove directive, if present, from CFG_RUSTC_FLAGS (issue #7898).
-CTEST_RUSTC_FLAGS := $$(subst --cfg ndebug,,$$(CFG_RUSTC_FLAGS))
+CTEST_RUSTC_FLAGS := --sysroot $$(HROOT$(1)_H_$(3)) $$(subst --cfg ndebug,,$$(CFG_RUSTC_FLAGS))
 
 # The tests cannot be optimized while the rest of the compiler is optimized, so
 # filter out the optimization (if any) from rustc and then figure out if we need
 # to be optimized
 CTEST_RUSTC_FLAGS := $$(subst -O,,$$(CTEST_RUSTC_FLAGS))
 ifndef CFG_DISABLE_OPTIMIZE_TESTS
 CTEST_RUSTC_FLAGS += -O
 endif
diff --git a/src/compiletest/util.rs b/src/compiletest/util.rs
index a116cc3..f4050f7 100644
--- a/src/compiletest/util.rs
+++ b/src/compiletest/util.rs
@@ -18,16 +18,17 @@ static OS_TABLE: &'static [(&'static str, &'static str)] = &[
     ("mingw32", "windows"),
     ("win32", "windows"),
     ("windows", "windows"),
     ("darwin", "macos"),
     ("android", "android"),
     ("linux", "linux"),
     ("freebsd", "freebsd"),
     ("dragonfly", "dragonfly"),
+    ("bitrig", "bitrig"),
 ];
 
 pub fn get_os(triple: &str) -> &'static str {
     for &(triple_os, os) in OS_TABLE.iter() {
         if triple.contains(triple_os) {
             return os
         }
     }
diff --git a/src/doc/reference.md b/src/doc/reference.md
index a907f09..7704dfd 100644
--- a/src/doc/reference.md
+++ b/src/doc/reference.md
@@ -2162,17 +2162,18 @@ The following configurations must be defined by the implementation:
 * `target_arch = "..."`. Target CPU architecture, such as `"x86"`, `"x86_64"`
   `"mips"`, `"arm"`, or `"aarch64"`.
 * `target_endian = "..."`. Endianness of the target CPU, either `"little"` or
   `"big"`.
 * `target_family = "..."`. Operating system family of the target, e. g.
   `"unix"` or `"windows"`. The value of this configuration option is defined
   as a configuration itself, like `unix` or `windows`.
 * `target_os = "..."`. Operating system of the target, examples include
-  `"win32"`, `"macos"`, `"linux"`, `"android"`, `"freebsd"` or `"dragonfly"`.
+  `"win32"`, `"macos"`, `"linux"`, `"android"`, `"freebsd"`, `"dragonfly"`, or
+  `"bitrig"`.
 * `target_word_size = "..."`. Target word size in bits. This is set to `"32"`
   for targets with 32-bit pointers, and likewise set to `"64"` for 64-bit
   pointers.
 * `unix`. See `target_family`.
 * `windows`. See `target_family`.
 
 ### Lint check attributes
 
diff --git a/src/etc/local_stage0.sh b/src/etc/local_stage0.sh
index 56ebd4f..6eac786 100755
--- a/src/etc/local_stage0.sh
+++ b/src/etc/local_stage0.sh
@@ -13,17 +13,17 @@ TARG_DIR=$1
 PREFIX=$2
 RUSTLIBDIR=$3
 
 LIB_DIR=lib
 LIB_PREFIX=lib
 
 OS=`uname -s`
 case $OS in
-    ("Linux"|"FreeBSD"|"DragonFly")
+    ("Linux"|"FreeBSD"|"DragonFly"|"Bitrig")
     BIN_SUF=
     LIB_SUF=.so
     break
     ;;
     ("Darwin")
     BIN_SUF=
     LIB_SUF=.dylib
     break
diff --git a/src/etc/snapshot.py b/src/etc/snapshot.py
index 8f45f7f..53fc324 100644
--- a/src/etc/snapshot.py
+++ b/src/etc/snapshot.py
@@ -33,16 +33,17 @@ download_dir_base = "dl"
 download_unpack_base = os.path.join(download_dir_base, "unpack")
 
 snapshot_files = {
     "linux": ["bin/rustc"],
     "macos": ["bin/rustc"],
     "winnt": ["bin/rustc.exe"],
     "freebsd": ["bin/rustc"],
     "dragonfly": ["bin/rustc"],
+    "bitrig": ["bin/rustc"],
     }
 
 winnt_runtime_deps_32 = ["libgcc_s_dw2-1.dll",
                          "libstdc++-6.dll"]
 winnt_runtime_deps_64 = ["libgcc_s_seh-1.dll",
                          "libstdc++-6.dll"]
 
 def parse_line(n, line):
@@ -84,16 +85,18 @@ def get_kernel(triple):
     if os_name == "windows":
         return "winnt"
     if os_name == "darwin":
         return "macos"
     if os_name == "freebsd":
         return "freebsd"
     if os_name == "dragonfly":
         return "dragonfly"
+    if os_name == "bitrig":
+        return "bitrig"
     return "linux"
 
 def get_cpu(triple):
     arch = triple.split('-')[0]
     if arch == "i686":
       return "i386"
     return arch
 
diff --git a/src/libbacktrace/configure b/src/libbacktrace/configure
index f4f9d05..1d495bb 100755
--- a/src/libbacktrace/configure
+++ b/src/libbacktrace/configure
@@ -5645,17 +5645,17 @@ else
     ;;
 
   amigaos*)
     # On AmigaOS with pdksh, this test takes hours, literally.
     # So we just punt and use a minimum line length of 8192.
     lt_cv_sys_max_cmd_len=8192;
     ;;
 
-  netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)
+  netbsd* | freebsd* | openbsd* | darwin* | dragonfly* | bitrig*)
     # This has been around since 386BSD, at least.  Likely further.
     if test -x /sbin/sysctl; then
       lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`
     elif test -x /usr/sbin/sysctl; then
       lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`
     else
       lt_cv_sys_max_cmd_len=65536	# usable default for all BSDs
     fi
diff --git a/src/libbacktrace/ltmain.sh b/src/libbacktrace/ltmain.sh
index 9503ec8..eaef55a 100644
--- a/src/libbacktrace/ltmain.sh
+++ b/src/libbacktrace/ltmain.sh
@@ -4736,17 +4736,17 @@ func_mode_link ()
 	  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-beos* | *-cegcc* | *-*-haiku*)
 	    # These systems don't actually have a C or math library (as such)
 	    continue
 	    ;;
 	  *-*-os2*)
 	    # These systems don't actually have a C library (as such)
 	    test "X$arg" = "X-lc" && continue
 	    ;;
-	  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)
+	  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly* | *-*-bitrig*)
 	    # Do not include libc due to us having libc/libc_r.
 	    test "X$arg" = "X-lc" && continue
 	    ;;
 	  *-*-rhapsody* | *-*-darwin1.[012])
 	    # Rhapsody C and math libraries are in the System framework
 	    deplibs="$deplibs System.ltframework"
 	    continue
 	    ;;
diff --git a/src/liblibc/lib.rs b/src/liblibc/lib.rs
index e48272b..13d61ba 100644
--- a/src/liblibc/lib.rs
+++ b/src/liblibc/lib.rs
@@ -276,30 +276,31 @@ pub use funcs::bsd43::{shutdown};
 #[cfg(windows)] pub use funcs::extra::kernel32::{DisconnectNamedPipe, OpenProcess};
 #[cfg(windows)] pub use funcs::extra::kernel32::{MoveFileExW, VirtualProtect};
 #[cfg(windows)] pub use funcs::extra::msvcrt::{get_osfhandle, open_osfhandle};
 #[cfg(windows)] pub use funcs::extra::winsock::{ioctlsocket};
 
 #[cfg(any(target_os = "linux",
           target_os = "android",
           target_os = "freebsd",
-          target_os = "dragonfly"))]
+          target_os = "dragonfly",
+          target_os = "bitrig"))]
 pub use consts::os::posix01::{CLOCK_REALTIME, CLOCK_MONOTONIC};
 
 #[cfg(any(target_os = "linux", target_os = "android"))]
 pub use funcs::posix01::unistd::{fdatasync};
 #[cfg(any(target_os = "linux", target_os = "android"))]
 pub use types::os::arch::extra::{sockaddr_ll};
 #[cfg(any(target_os = "linux", target_os = "android"))]
 pub use consts::os::extra::{AF_PACKET};
 
-#[cfg(all(unix, not(target_os = "freebsd")))]
+#[cfg(all(unix, not(any(target_os = "freebsd", target_os = "bitrig"))))]
 pub use consts::os::extra::{MAP_STACK};
 
-#[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+#[cfg(any(target_os = "freebsd", target_os = "dragonfly", target_os = "bitrig"))]
 pub use consts::os::bsd44::{TCP_KEEPIDLE};
 
 #[cfg(any(target_os = "macos", target_os = "ios"))]
 pub use consts::os::bsd44::{TCP_KEEPALIVE};
 #[cfg(any(target_os = "macos", target_os = "ios"))]
 pub use consts::os::extra::{F_FULLFSYNC};
 
 #[cfg(any(target_os = "macos", target_os = "ios"))]
@@ -1326,16 +1327,232 @@ pub mod types {
             }
             pub mod bsd44 {
             }
             pub mod extra {
             }
         }
     }
 
+    #[cfg(target_os = "bitrig")]
+    pub mod os {
+        pub mod common {
+            pub mod posix01 {
+                use types::common::c95::{c_void};
+                use types::os::arch::c95::{c_char, c_int, size_t,
+                                                 time_t, suseconds_t, c_long};
+                use types::os::arch::c99::{uintptr_t};
+
+                pub type pthread_t = uintptr_t;
+
+                #[repr(C)]
+                #[deriving(Copy)] pub struct glob_t {
+                    pub gl_pathc:  c_int,
+                    pub gl_matchc: c_int,
+                    pub gl_offs:   c_int,
+                    pub gl_flags:  c_int,
+                    pub gl_pathv:  *mut *mut c_char,
+                    pub __unused1: *mut c_void,
+                    pub __unused2: *mut c_void,
+                    pub __unused3: *mut c_void,
+                    pub __unused4: *mut c_void,
+                    pub __unused5: *mut c_void,
+                    pub __unused6: *mut c_void,
+                    pub __unused7: *mut c_void,
+                }
+
+                #[repr(C)]
+                #[deriving(Copy)] pub struct timeval {
+                    pub tv_sec: time_t,
+                    pub tv_usec: suseconds_t,
+                }
+
+                #[repr(C)]
+                #[deriving(Copy)] pub struct timespec {
+                    pub tv_sec: time_t,
+                    pub tv_nsec: c_long,
+                }
+
+                #[deriving(Copy)] pub enum timezone {}
+
+                pub type sighandler_t = size_t;
+            }
+            pub mod bsd44 {
+                use types::common::c95::{c_void};
+                use types::os::arch::c95::{c_char, c_int, c_uint};
+
+                pub type socklen_t = u32;
+                pub type sa_family_t = u8;
+                pub type in_port_t = u16;
+                pub type in_addr_t = u32;
+                #[repr(C)]
+                #[deriving(Copy)] pub struct sockaddr {
+                    pub sa_len: u8,
+                    pub sa_family: sa_family_t,
+                    pub sa_data: [u8; 14],
+                }
+                #[repr(C)]
+                #[deriving(Copy)] pub struct sockaddr_storage {
+                    pub ss_len: u8,
+                    pub ss_family: sa_family_t,
+                    pub __ss_pad1: [u8; 6],
+                    pub __ss_align: i64,
+                    pub __ss_pad2: [u8; 112],
+                }
+                #[repr(C)]
+                #[deriving(Copy)] pub struct sockaddr_in {
+                    pub sin_len: u8,
+                    pub sin_family: sa_family_t,
+                    pub sin_port: in_port_t,
+                    pub sin_addr: in_addr,
+                    pub sin_zero: [u8; 8],
+                }
+                #[repr(C)]
+                #[deriving(Copy)] pub struct in_addr {
+                    pub s_addr: in_addr_t,
+                }
+                #[repr(C)]
+                #[deriving(Copy)] pub struct sockaddr_in6 {
+                    pub sin6_len: u8,
+                    pub sin6_family: sa_family_t,
+                    pub sin6_port: in_port_t,
+                    pub sin6_flowinfo: u32,
+                    pub sin6_addr: in6_addr,
+                    pub sin6_scope_id: u32,
+                }
+                #[repr(C)]
+                #[deriving(Copy)] pub struct in6_addr {
+                    pub s6_addr: [u16; 8]
+                }
+                #[repr(C)]
+                #[deriving(Copy)] pub struct ip_mreq {
+                    pub imr_multiaddr: in_addr,
+                    pub imr_interface: in_addr,
+                }
+                #[repr(C)]
+                #[deriving(Copy)] pub struct ip6_mreq {
+                    pub ipv6mr_multiaddr: in6_addr,
+                    pub ipv6mr_interface: c_uint,
+                }
+                #[repr(C)]
+                #[deriving(Copy)] pub struct addrinfo {
+                    pub ai_flags: c_int,
+                    pub ai_family: c_int,
+                    pub ai_socktype: c_int,
+                    pub ai_protocol: c_int,
+                    pub ai_addrlen: socklen_t,
+                    pub ai_canonname: *mut c_char,
+                    pub ai_addr: *mut sockaddr,
+                    pub ai_next: *mut addrinfo,
+                }
+                #[repr(C)]
+                #[deriving(Copy)] pub struct sockaddr_un {
+                    pub sun_len: u8,
+                    pub sun_family: sa_family_t,
+                    pub sun_path: [c_char; 104]
+                }
+                #[repr(C)]
+                #[deriving(Copy)] pub struct ifaddrs {
+                    pub ifa_next: *mut ifaddrs,
+                    pub ifa_name: *mut c_char,
+                    pub ifa_flags: c_uint,
+                    pub ifa_addr: *mut sockaddr,
+                    pub ifa_netmask: *mut sockaddr,
+                    pub ifa_dstaddr: *mut sockaddr,
+                    pub ifa_data: *mut c_void
+                }
+            }
+        }
+
+        #[cfg(target_arch = "x86_64")]
+        pub mod arch {
+            pub mod c95 {
+                pub type c_char = i8;
+                pub type c_schar = i8;
+                pub type c_uchar = u8;
+                pub type c_short = i16;
+                pub type c_ushort = u16;
+                pub type c_int = i32;
+                pub type c_uint = u32;
+                pub type c_long = i64;
+                pub type c_ulong = u64;
+                pub type c_float = f32;
+                pub type c_double = f64;
+                pub type size_t = u64;
+                pub type ptrdiff_t = i64;
+                pub type clock_t = i64;
+                pub type time_t = i64;
+                pub type suseconds_t = i64;
+                pub type wchar_t = i32;
+            }
+            pub mod c99 {
+                pub type c_longlong = i64;
+                pub type c_ulonglong = u64;
+                pub type intptr_t = i64;
+                pub type uintptr_t = u64;
+                pub type intmax_t = i64;
+                pub type uintmax_t = u64;
+            }
+            pub mod posix88 {
+                use types::os::arch::c95::{c_long};
+                pub type off_t = i64;
+                pub type dev_t = i32;
+                pub type ino_t = u64;
+                pub type pid_t = i32;
+                pub type uid_t = u32;
+                pub type gid_t = u32;
+                pub type useconds_t = u32;
+                pub type mode_t = u32;
+                pub type ssize_t = c_long;
+            }
+            pub mod posix01 {
+                use types::common::c95::{c_void};
+                use types::os::arch::c95::{time_t};
+                use types::common::c99::{uint32_t, int64_t};
+                use types::os::arch::posix88::{dev_t, gid_t, ino_t, mode_t, off_t, uid_t};
+                use types::os::common::posix01::{timespec};
+
+                pub type nlink_t = uint32_t;
+
+                #[repr(C)]
+                #[deriving(Copy)] pub struct stat {
+                    pub st_mode: mode_t,
+                    pub st_dev: dev_t,
+                    pub st_ino: ino_t,
+                    pub st_nlink: nlink_t,
+                    pub st_uid: uid_t,
+                    pub st_gid: gid_t,
+                    pub st_rdev: dev_t,
+                    pub st_atim: timespec,
+                    pub st_mtim: timespec,
+                    pub st_ctim: timespec,
+                    pub st_size: off_t,
+                    pub st_blocks: int64_t,
+                    pub st_blksize: uint32_t,
+                    pub st_flags: uint32_t,
+                    pub st_gen: uint32_t,
+                    pub __st_birthtim: timespec,
+                }
+                #[repr(C)]
+                #[deriving(Copy)] pub struct utimbuf {
+                    pub actime: time_t,
+                    pub modtime: time_t,
+                }
+
+                pub type pthread_attr_t = *mut c_void;
+            }
+            pub mod posix08 {
+            }
+            pub mod bsd44 {
+            }
+            pub mod extra {
+            }
+        }
+    }
+
     #[cfg(target_os = "windows")]
     pub mod os {
         pub mod common {
             pub mod posix01 {
                 use types::os::arch::c95::{c_short, time_t, c_long};
                 use types::os::arch::extra::{int64, time64_t};
                 use types::os::arch::posix88::{dev_t, ino_t};
 
@@ -3596,16 +3813,19 @@ pub mod consts {
             pub const MAP_RENAME : c_int = 0x0020;
             pub const MAP_NORESERVE : c_int = 0x0040;
             pub const MAP_HASSEMAPHORE : c_int = 0x0200;
             pub const MAP_STACK : c_int = 0x0400;
             pub const MAP_NOSYNC : c_int = 0x0800;
             pub const MAP_NOCORE : c_int = 0x020000;
 
             pub const IPPROTO_RAW : c_int = 255;
+
+            #[cfg(target_os = "bitrig")]
+            pub const PATH_MAX: c_int = 1024;
         }
         pub mod sysconf {
             use types::os::arch::c95::c_int;
 
             pub const _SC_ARG_MAX : c_int = 1;
             pub const _SC_CHILD_MAX : c_int = 2;
             pub const _SC_CLK_TCK : c_int = 3;
             pub const _SC_NGROUPS_MAX : c_int = 4;
@@ -3655,16 +3875,394 @@ pub mod consts {
             pub const _SC_RTSIG_MAX : c_int = 48;
             pub const _SC_SEM_NSEMS_MAX : c_int = 49;
             pub const _SC_SEM_VALUE_MAX : c_int = 50;
             pub const _SC_SIGQUEUE_MAX : c_int = 51;
             pub const _SC_TIMER_MAX : c_int = 52;
         }
     }
 
+    #[cfg(target_os = "bitrig")]
+    pub mod os {
+        pub mod c95 {
+            use types::os::arch::c95::{c_int, c_uint};
+
+            pub const EXIT_FAILURE : c_int = 1;
+            pub const EXIT_SUCCESS : c_int = 0;
+            pub const RAND_MAX : c_int = 2147483647;
+            pub const EOF : c_int = -1;
+            pub const SEEK_SET : c_int = 0;
+            pub const SEEK_CUR : c_int = 1;
+            pub const SEEK_END : c_int = 2;
+            pub const _IOFBF : c_int = 0;
+            pub const _IONBF : c_int = 2;
+            pub const _IOLBF : c_int = 1;
+            pub const BUFSIZ : c_uint = 1024_u32;
+            pub const FOPEN_MAX : c_uint = 20_u32;
+            pub const FILENAME_MAX : c_uint = 1024_u32;
+            pub const L_tmpnam : c_uint = 1024_u32;
+            pub const TMP_MAX : c_uint = 308915776_u32;
+        }
+        pub mod c99 {
+        }
+        pub mod posix88 {
+            use types::common::c95::c_void;
+            use types::os::arch::c95::c_int;
+            use types::os::arch::posix88::mode_t;
+
+            pub const O_RDONLY : c_int = 0;
+            pub const O_WRONLY : c_int = 1;
+            pub const O_RDWR : c_int = 2;
+            pub const O_APPEND : c_int = 8;
+            pub const O_CREAT : c_int = 512;
+            pub const O_EXCL : c_int = 2048;
+            pub const O_TRUNC : c_int = 1024;
+            pub const S_IFIFO : mode_t = 4096;
+            pub const S_IFCHR : mode_t = 8192;
+            pub const S_IFBLK : mode_t = 24576;
+            pub const S_IFDIR : mode_t = 16384;
+            pub const S_IFREG : mode_t = 32768;
+            pub const S_IFLNK : mode_t = 40960;
+            pub const S_IFMT : mode_t = 61440;
+            pub const S_IEXEC : mode_t = 64;
+            pub const S_IWRITE : mode_t = 128;
+            pub const S_IREAD : mode_t = 256;
+            pub const S_IRWXU : mode_t = 448;
+            pub const S_IXUSR : mode_t = 64;
+            pub const S_IWUSR : mode_t = 128;
+            pub const S_IRUSR : mode_t = 256;
+            pub const F_OK : c_int = 0;
+            pub const R_OK : c_int = 4;
+            pub const W_OK : c_int = 2;
+            pub const X_OK : c_int = 1;
+            pub const STDIN_FILENO : c_int = 0;
+            pub const STDOUT_FILENO : c_int = 1;
+            pub const STDERR_FILENO : c_int = 2;
+            pub const F_LOCK : c_int = 1;
+            pub const F_TEST : c_int = 3;
+            pub const F_TLOCK : c_int = 2;
+            pub const F_ULOCK : c_int = 0;
+            pub const SIGHUP : c_int = 1;
+            pub const SIGINT : c_int = 2;
+            pub const SIGQUIT : c_int = 3;
+            pub const SIGILL : c_int = 4;
+            pub const SIGABRT : c_int = 6;
+            pub const SIGFPE : c_int = 8;
+            pub const SIGKILL : c_int = 9;
+            pub const SIGSEGV : c_int = 11;
+            pub const SIGPIPE : c_int = 13;
+            pub const SIGALRM : c_int = 14;
+            pub const SIGTERM : c_int = 15;
+
+            pub const PROT_NONE : c_int = 0;
+            pub const PROT_READ : c_int = 1;
+            pub const PROT_WRITE : c_int = 2;
+            pub const PROT_EXEC : c_int = 4;
+
+            pub const MAP_FILE : c_int = 0x0000;
+            pub const MAP_SHARED : c_int = 0x0001;
+            pub const MAP_PRIVATE : c_int = 0x0002;
+            pub const MAP_FIXED : c_int = 0x0010;
+            pub const MAP_ANON : c_int = 0x1000;
+
+            pub const MAP_FAILED : *mut c_void = -1 as *mut c_void;
+
+            pub const MCL_CURRENT : c_int = 0x0001;
+            pub const MCL_FUTURE : c_int = 0x0002;
+
+            pub const MS_ASYNC : c_int = 0x0001;
+            pub const MS_SYNC : c_int = 0x0002;
+            pub const MS_INVALIDATE : c_int = 0x0004;
+
+            pub const EPERM : c_int = 1;
+            pub const ENOENT : c_int = 2;
+            pub const ESRCH : c_int = 3;
+            pub const EINTR : c_int = 4;
+            pub const EIO : c_int = 5;
+            pub const ENXIO : c_int = 6;
+            pub const E2BIG : c_int = 7;
+            pub const ENOEXEC : c_int = 8;
+            pub const EBADF : c_int = 9;
+            pub const ECHILD : c_int = 10;
+            pub const EDEADLK : c_int = 11;
+            pub const ENOMEM : c_int = 12;
+            pub const EACCES : c_int = 13;
+            pub const EFAULT : c_int = 14;
+            pub const ENOTBLK : c_int = 15;
+            pub const EBUSY : c_int = 16;
+            pub const EEXIST : c_int = 17;
+            pub const EXDEV : c_int = 18;
+            pub const ENODEV : c_int = 19;
+            pub const ENOTDIR : c_int = 20;
+            pub const EISDIR : c_int = 21;
+            pub const EINVAL : c_int = 22;
+            pub const ENFILE : c_int = 23;
+            pub const EMFILE : c_int = 24;
+            pub const ENOTTY : c_int = 25;
+            pub const ETXTBSY : c_int = 26;
+            pub const EFBIG : c_int = 27;
+            pub const ENOSPC : c_int = 28;
+            pub const ESPIPE : c_int = 29;
+            pub const EROFS : c_int = 30;
+            pub const EMLINK : c_int = 31;
+            pub const EPIPE : c_int = 32;
+            pub const EDOM : c_int = 33;
+            pub const ERANGE : c_int = 34;
+            pub const EAGAIN : c_int = 35;
+            pub const EWOULDBLOCK : c_int = 35;
+            pub const EINPROGRESS : c_int = 36;
+            pub const EALREADY : c_int = 37;
+            pub const ENOTSOCK : c_int = 38;
+            pub const EDESTADDRREQ : c_int = 39;
+            pub const EMSGSIZE : c_int = 40;
+            pub const EPROTOTYPE : c_int = 41;
+            pub const ENOPROTOOPT : c_int = 42;
+            pub const EPROTONOSUPPORT : c_int = 43;
+            pub const ESOCKTNOSUPPORT : c_int = 44;
+            pub const EOPNOTSUPP : c_int = 45;
+            pub const EPFNOSUPPORT : c_int = 46;
+            pub const EAFNOSUPPORT : c_int = 47;
+            pub const EADDRINUSE : c_int = 48;
+            pub const EADDRNOTAVAIL : c_int = 49;
+            pub const ENETDOWN : c_int = 50;
+            pub const ENETUNREACH : c_int = 51;
+            pub const ENETRESET : c_int = 52;
+            pub const ECONNABORTED : c_int = 53;
+            pub const ECONNRESET : c_int = 54;
+            pub const ENOBUFS : c_int = 55;
+            pub const EISCONN : c_int = 56;
+            pub const ENOTCONN : c_int = 57;
+            pub const ESHUTDOWN : c_int = 58;
+            pub const ETOOMANYREFS : c_int = 59;
+            pub const ETIMEDOUT : c_int = 60;
+            pub const ECONNREFUSED : c_int = 61;
+            pub const ELOOP : c_int = 62;
+            pub const ENAMETOOLONG : c_int = 63;
+            pub const EHOSTDOWN : c_int = 64;
+            pub const EHOSTUNREACH : c_int = 65;
+            pub const ENOTEMPTY : c_int = 66;
+            pub const EPROCLIM : c_int = 67;
+            pub const EUSERS : c_int = 68;
+            pub const EDQUOT : c_int = 69;
+            pub const ESTALE : c_int = 70;
+            pub const EREMOTE : c_int = 71;
+            pub const EBADRPC : c_int = 72;
+            pub const ERPCMISMATCH : c_int = 73;
+            pub const EPROGUNAVAIL : c_int = 74;
+            pub const EPROGMISMATCH : c_int = 75;
+            pub const EPROCUNAVAIL : c_int = 76;
+            pub const ENOLCK : c_int = 77;
+            pub const ENOSYS : c_int = 78;
+            pub const EFTYPE : c_int = 79;
+            pub const EAUTH : c_int = 80;
+            pub const ENEEDAUTH : c_int = 81;
+            pub const EIPSEC : c_int = 82;
+            pub const ENOATTR : c_int = 83;
+            pub const EILSEQ : c_int = 84;
+            pub const ENOMEDIUM : c_int = 85;
+            pub const EMEDIUMTYPE : c_int = 86;
+            pub const EOVERFLOW : c_int = 87;
+            pub const ECANCELED : c_int = 88;
+            pub const EIDRM : c_int = 89;
+            pub const ENOMSG : c_int = 90;
+            pub const ENOTSUP : c_int = 91;
+            pub const ELAST : c_int = 91; // must be equal to largest errno
+        }
+        pub mod posix01 {
+            use types::os::arch::c95::{c_int, size_t};
+
+            pub const F_DUPFD : c_int = 0;
+            pub const F_GETFD : c_int = 1;
+            pub const F_SETFD : c_int = 2;
+            pub const F_GETFL : c_int = 3;
+            pub const F_SETFL : c_int = 4;
+            pub const F_GETOWN : c_int = 5;
+            pub const F_SETOWN : c_int = 6;
+            pub const F_GETLK : c_int = 7;
+            pub const F_SETLK : c_int = 8;
+            pub const F_SETLKW : c_int = 9;
+            pub const F_DUPFD_CLOEXEC : c_int = 10;
+
+            pub const SIGTRAP : c_int = 5;
+            pub const SIGPIPE: c_int = 13;
+            pub const SIG_IGN: size_t = 1;
+
+            pub const GLOB_APPEND   : c_int = 0x0001;
+            pub const GLOB_DOOFFS   : c_int = 0x0002;
+            pub const GLOB_ERR      : c_int = 0x0004;
+            pub const GLOB_MARK     : c_int = 0x0008;
+            pub const GLOB_NOCHECK  : c_int = 0x0010;
+            pub const GLOB_NOSORT   : c_int = 0x0020;
+            pub const GLOB_NOESCAPE : c_int = 0x1000;
+
+            pub const GLOB_NOSPACE  : c_int = -1;
+            pub const GLOB_ABORTED  : c_int = -2;
+            pub const GLOB_NOMATCH  : c_int = -3;
+            pub const GLOB_NOSYS : c_int = -4;
+
+            pub const POSIX_MADV_NORMAL : c_int = 0;
+            pub const POSIX_MADV_RANDOM : c_int = 1;
+            pub const POSIX_MADV_SEQUENTIAL : c_int = 2;
+            pub const POSIX_MADV_WILLNEED : c_int = 3;
+            pub const POSIX_MADV_DONTNEED : c_int = 4;
+
+            pub const _SC_IOV_MAX : c_int = 51;
+            pub const _SC_GETGR_R_SIZE_MAX : c_int = 100;
+            pub const _SC_GETPW_R_SIZE_MAX : c_int = 101;
+            pub const _SC_LOGIN_NAME_MAX : c_int = 102;
+            pub const _SC_MQ_PRIO_MAX : c_int = 59;
+            pub const _SC_THREAD_ATTR_STACKADDR : c_int = 77;
+            pub const _SC_THREAD_ATTR_STACKSIZE : c_int = 78;
+            pub const _SC_THREAD_DESTRUCTOR_ITERATIONS : c_int = 80;
+            pub const _SC_THREAD_KEYS_MAX : c_int = 81;
+            pub const _SC_THREAD_PRIO_INHERIT : c_int = 82;
+            pub const _SC_THREAD_PRIO_PROTECT : c_int = 83;
+            pub const _SC_THREAD_PRIORITY_SCHEDULING : c_int = 84;
+            pub const _SC_THREAD_PROCESS_SHARED : c_int = 85;
+            pub const _SC_THREAD_SAFE_FUNCTIONS : c_int = 103;
+            pub const _SC_THREAD_STACK_MIN : c_int = 89;
+            pub const _SC_THREAD_THREADS_MAX : c_int = 90;
+            pub const _SC_THREADS : c_int = 91;
+            pub const _SC_TTY_NAME_MAX : c_int = 107;
+            pub const _SC_ATEXIT_MAX : c_int = 146;
+            pub const _SC_XOPEN_CRYPT : c_int = 117;
+            pub const _SC_XOPEN_ENH_I18N : c_int = 118;
+            pub const _SC_XOPEN_LEGACY : c_int = 119;
+            pub const _SC_XOPEN_REALTIME : c_int = 120;
+            pub const _SC_XOPEN_REALTIME_THREADS : c_int = 121;
+            pub const _SC_XOPEN_SHM : c_int = 30;
+            pub const _SC_XOPEN_UNIX : c_int = 123;
+            pub const _SC_XOPEN_VERSION : c_int = 125;
+
+            pub const PTHREAD_CREATE_JOINABLE : c_int = 0;
+            pub const PTHREAD_CREATE_DETACHED : c_int = 1;
+            pub const PTHREAD_STACK_MIN : size_t = 2048;
+
+            pub const CLOCK_REALTIME : c_int = 0;
+            pub const CLOCK_MONOTONIC : c_int = 3;
+        }
+        pub mod posix08 {
+        }
+        pub mod bsd44 {
+            use types::os::arch::c95::c_int;
+
+            pub const MADV_NORMAL : c_int = 0;
+            pub const MADV_RANDOM : c_int = 1;
+            pub const MADV_SEQUENTIAL : c_int = 2;
+            pub const MADV_WILLNEED : c_int = 3;
+            pub const MADV_DONTNEED : c_int = 4;
+            pub const MADV_FREE : c_int = 6;
+
+            pub const AF_UNIX: c_int = 1;
+            pub const AF_INET: c_int = 2;
+            pub const AF_INET6: c_int = 24;
+            pub const SOCK_STREAM: c_int = 1;
+            pub const SOCK_DGRAM: c_int = 2;
+            pub const SOCK_RAW: c_int = 3;
+            pub const IPPROTO_TCP: c_int = 6;
+            pub const IPPROTO_IP: c_int = 0;
+            pub const IPPROTO_IPV6: c_int = 41;
+            pub const IP_MULTICAST_TTL: c_int = 10;
+            pub const IP_MULTICAST_LOOP: c_int = 11;
+            pub const IP_TTL: c_int = 4;
+            pub const IP_HDRINCL: c_int = 2;
+            pub const IP_ADD_MEMBERSHIP: c_int = 12;
+            pub const IP_DROP_MEMBERSHIP: c_int = 13;
+            pub const IPV6_ADD_MEMBERSHIP: c_int = 12; // don't exist
+            pub const IPV6_DROP_MEMBERSHIP: c_int = 13; // don't exist
+
+            pub const TCP_NODELAY: c_int = 0x01;
+            pub const SOL_SOCKET: c_int = 0xffff;
+            pub const SO_KEEPALIVE: c_int = 0x0008;
+            pub const SO_BROADCAST: c_int = 0x0020;
+            pub const SO_REUSEADDR: c_int = 0x0004;
+            pub const SO_ERROR: c_int = 0x1007;
+
+            pub const IFF_LOOPBACK: c_int = 0x8;
+
+            pub const SHUT_RD: c_int = 0;
+            pub const SHUT_WR: c_int = 1;
+            pub const SHUT_RDWR: c_int = 2;
+        }
+        pub mod extra {
+            use types::os::arch::c95::c_int;
+
+            pub const O_DSYNC : c_int = 128; // same as SYNC
+            pub const O_SYNC : c_int = 128;
+            pub const O_NONBLOCK : c_int = 4;
+            pub const CTL_KERN : c_int = 1;
+            pub const KERN_PROC : c_int = 66;
+
+            pub const MAP_COPY : c_int = 0x0002;
+            pub const MAP_RENAME : c_int = 0x0000;
+            pub const MAP_NORESERVE : c_int = 0x0000;
+            pub const MAP_NOEXTEND : c_int = 0x0000;
+            pub const MAP_HASSEMAPHORE : c_int = 0x0000;
+
+            pub const IPPROTO_RAW : c_int = 255;
+        }
+        pub mod sysconf {
+            use types::os::arch::c95::c_int;
+
+            pub const _SC_ARG_MAX : c_int = 1;
+            pub const _SC_CHILD_MAX : c_int = 2;
+            pub const _SC_CLK_TCK : c_int = 3;
+            pub const _SC_NGROUPS_MAX : c_int = 4;
+            pub const _SC_OPEN_MAX : c_int = 5;
+            pub const _SC_JOB_CONTROL : c_int = 6;
+            pub const _SC_SAVED_IDS : c_int = 7;
+            pub const _SC_VERSION : c_int = 8;
+            pub const _SC_BC_BASE_MAX : c_int = 9;
+            pub const _SC_BC_DIM_MAX : c_int = 10;
+            pub const _SC_BC_SCALE_MAX : c_int = 11;
+            pub const _SC_BC_STRING_MAX : c_int = 12;
+            pub const _SC_COLL_WEIGHTS_MAX : c_int = 13;
+            pub const _SC_EXPR_NEST_MAX : c_int = 14;
+            pub const _SC_LINE_MAX : c_int = 15;
+            pub const _SC_RE_DUP_MAX : c_int = 16;
+            pub const _SC_2_VERSION : c_int = 17;
+            pub const _SC_2_C_BIND : c_int = 18;
+            pub const _SC_2_C_DEV : c_int = 19;
+            pub const _SC_2_CHAR_TERM : c_int = 20;
+            pub const _SC_2_FORT_DEV : c_int = 21;
+            pub const _SC_2_FORT_RUN : c_int = 22;
+            pub const _SC_2_LOCALEDEF : c_int = 23;
+            pub const _SC_2_SW_DEV : c_int = 24;
+            pub const _SC_2_UPE : c_int = 25;
+            pub const _SC_STREAM_MAX : c_int = 26;
+            pub const _SC_TZNAME_MAX : c_int = 27;
+            pub const _SC_PAGESIZE : c_int = 28;
+            pub const _SC_ASYNCHRONOUS_IO : c_int = 45;
+            pub const _SC_FSYNC : c_int = 29;
+            pub const _SC_MEMLOCK : c_int = 54;
+            pub const _SC_MEMLOCK_RANGE : c_int = 55;
+            pub const _SC_MEMORY_PROTECTION : c_int = 56;
+            pub const _SC_MESSAGE_PASSING : c_int = 57;
+            pub const _SC_PRIORITIZED_IO : c_int = 60;
+            pub const _SC_PRIORITY_SCHEDULING : c_int = 61;
+            pub const _SC_REALTIME_SIGNALS : c_int = 64;
+            pub const _SC_SEMAPHORES : c_int = 67;
+            pub const _SC_FSYNC : c_int = 29;
+            pub const _SC_SHARED_MEMORY_OBJECTS : c_int = 68;
+            pub const _SC_SYNCHRONIZED_IO : c_int = 75;
+            pub const _SC_TIMERS : c_int = 94;
+            pub const _SC_AIO_LISTIO_MAX : c_int = 42;
+            pub const _SC_AIO_MAX : c_int = 43;
+            pub const _SC_AIO_PRIO_DELTA_MAX : c_int = 44;
+            pub const _SC_DELAYTIMER_MAX : c_int = 50;
+            pub const _SC_MQ_OPEN_MAX : c_int = 58;
+            pub const _SC_MAPPED_FILES : c_int = 53;
+            pub const _SC_RTSIG_MAX : c_int = 66;
+            pub const _SC_SEM_NSEMS_MAX : c_int = 31;
+            pub const _SC_SEM_VALUE_MAX : c_int = 32;
+            pub const _SC_SIGQUEUE_MAX : c_int = 70;
+            pub const _SC_TIMER_MAX : c_int = 93;
+        }
+    }
+
     #[cfg(any(target_os = "macos", target_os = "ios"))]
     pub mod os {
         pub mod c95 {
             use types::os::arch::c95::{c_int, c_uint};
 
             pub const EXIT_FAILURE : c_int = 1;
             pub const EXIT_SUCCESS : c_int = 0;
             pub const RAND_MAX : c_int = 2147483647;
@@ -4351,44 +4949,47 @@ pub mod funcs {
         }
     }
 
     #[cfg(any(target_os = "linux",
               target_os = "android",
               target_os = "macos",
               target_os = "ios",
               target_os = "freebsd",
-              target_os = "dragonfly"))]
+              target_os = "dragonfly",
+              target_os = "bitrig"))]
     pub mod posix88 {
         pub mod stat_ {
             use types::os::arch::c95::{c_char, c_int};
             use types::os::arch::posix01::stat;
             use types::os::arch::posix88::mode_t;
 
             extern {
                 pub fn chmod(path: *const c_char, mode: mode_t) -> c_int;
                 pub fn fchmod(fd: c_int, mode: mode_t) -> c_int;
 
                 #[cfg(any(target_os = "linux",
                           target_os = "freebsd",
                           target_os = "dragonfly",
+                          target_os = "bitrig",
                           target_os = "android",
                           target_os = "ios"))]
                 pub fn fstat(fildes: c_int, buf: *mut stat) -> c_int;
 
                 #[cfg(target_os = "macos")]
                 #[link_name = "fstat64"]
                 pub fn fstat(fildes: c_int, buf: *mut stat) -> c_int;
 
                 pub fn mkdir(path: *const c_char, mode: mode_t) -> c_int;
                 pub fn mkfifo(path: *const c_char, mode: mode_t) -> c_int;
 
                 #[cfg(any(target_os = "linux",
                           target_os = "freebsd",
                           target_os = "dragonfly",
+                          target_os = "bitrig",
                           target_os = "android",
                           target_os = "ios"))]
                 pub fn stat(path: *const c_char, buf: *mut stat) -> c_int;
 
                 #[cfg(target_os = "macos")]
                 #[link_name = "stat64"]
                 pub fn stat(path: *const c_char, buf: *mut stat) -> c_int;
             }
@@ -4571,26 +5172,28 @@ pub mod funcs {
 
     }
 
     #[cfg(any(target_os = "linux",
               target_os = "android",
               target_os = "macos",
               target_os = "ios",
               target_os = "freebsd",
-              target_os = "dragonfly"))]
+              target_os = "dragonfly",
+              target_os = "bitrig"))]
     pub mod posix01 {
         pub mod stat_ {
             use types::os::arch::c95::{c_char, c_int};
             use types::os::arch::posix01::stat;
 
             extern {
                 #[cfg(any(target_os = "linux",
                           target_os = "freebsd",
                           target_os = "dragonfly",
+                          target_os = "bitrig",
                           target_os = "android",
                           target_os = "ios"))]
                 pub fn lstat(path: *const c_char, buf: *mut stat) -> c_int;
 
                 #[cfg(target_os = "macos")]
                 #[link_name = "lstat64"]
                 pub fn lstat(path: *const c_char, buf: *mut stat) -> c_int;
             }
@@ -4688,17 +5291,18 @@ pub mod funcs {
 
 
     #[cfg(any(target_os = "windows",
               target_os = "linux",
               target_os = "android",
               target_os = "macos",
               target_os = "ios",
               target_os = "freebsd",
-              target_os = "dragonfly"))]
+              target_os = "dragonfly",
+              target_os = "bitrig"))]
     pub mod posix08 {
         pub mod unistd {
         }
     }
 
     #[cfg(not(windows))]
     pub mod bsd43 {
         use types::common::c95::{c_void};
@@ -4774,17 +5378,18 @@ pub mod funcs {
                           addrlen: c_int) -> c_int;
             pub fn shutdown(socket: SOCKET, how: c_int) -> c_int;
         }
     }
 
     #[cfg(any(target_os = "macos",
               target_os = "ios",
               target_os = "freebsd",
-              target_os = "dragonfly"))]
+              target_os = "dragonfly",
+              target_os = "bitrig"))]
     pub mod bsd44 {
         use types::common::c95::{c_void};
         use types::os::arch::c95::{c_char, c_uchar, c_int, c_uint, c_ulong, size_t};
 
         extern {
             pub fn ioctl(d: c_int, request: c_ulong, ...) -> c_int;
             pub fn sysctl(name: *mut c_int,
                           namelen: c_uint,
@@ -4803,20 +5408,21 @@ pub mod funcs {
                                    mibp: *mut c_int,
                                    sizep: *mut size_t)
                                    -> c_int;
             pub fn getdtablesize() -> c_int;
             pub fn madvise(addr: *mut c_void, len: size_t, advice: c_int)
                            -> c_int;
             pub fn mincore(addr: *mut c_void, len: size_t, vec: *mut c_uchar)
                            -> c_int;
+            pub fn realpath(pathname: *const c_char, resolved: *mut c_char)
+                            -> *mut c_char;
         }
     }
 
-
     #[cfg(any(target_os = "linux", target_os = "android"))]
     pub mod bsd44 {
         use types::common::c95::{c_void};
         use types::os::arch::c95::{c_uchar, c_int, size_t};
 
         extern {
             pub fn getdtablesize() -> c_int;
             pub fn ioctl(d: c_int, request: c_int, ...) -> c_int;
@@ -4837,17 +5443,17 @@ pub mod funcs {
         use types::os::arch::c95::{c_char, c_int};
 
         extern {
             pub fn _NSGetExecutablePath(buf: *mut c_char, bufsize: *mut u32)
                                         -> c_int;
         }
     }
 
-    #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+    #[cfg(any(target_os = "freebsd", target_os = "dragonfly", target_os = "bitrig"))]
     pub mod extra {
     }
 
     #[cfg(any(target_os = "linux", target_os = "android"))]
     pub mod extra {
     }
 
 
diff --git a/src/librustc_back/arm.rs b/src/librustc_back/arm.rs
index 7e28cd6..f97a188 100644
--- a/src/librustc_back/arm.rs
+++ b/src/librustc_back/arm.rs
@@ -56,17 +56,17 @@ pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs
           abi::OsAndroid => {
             "e-p:32:32:32\
                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\
                 -f32:32:32-f64:64:64\
                 -v64:64:64-v128:64:128\
                 -a:0:64-n32".to_string()
           }
 
-          abi::OsFreebsd | abi::OsDragonfly => {
+          abi::OsFreebsd | abi::OsDragonfly | abi::OsBitrig => {
             "e-p:32:32:32\
                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\
                 -f32:32:32-f64:64:64\
                 -v64:64:64-v128:64:128\
                 -a:0:64-n32".to_string()
           }
         },
 
diff --git a/src/librustc_back/mips.rs b/src/librustc_back/mips.rs
index bc77321..bb67b9f 100644
--- a/src/librustc_back/mips.rs
+++ b/src/librustc_back/mips.rs
@@ -51,17 +51,17 @@ pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs
           abi::OsAndroid => {
             "E-p:32:32:32\
                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\
                 -f32:32:32-f64:64:64\
                 -v64:64:64-v128:64:128\
                 -a:0:64-n32".to_string()
           }
 
-          abi::OsFreebsd | abi::OsDragonfly => {
+          abi::OsFreebsd | abi::OsDragonfly | abi::OsBitrig => {
             "E-p:32:32:32\
                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\
                 -f32:32:32-f64:64:64\
                 -v64:64:64-v128:64:128\
                 -a:0:64-n32".to_string()
           }
         },
 
diff --git a/src/librustc_back/mipsel.rs b/src/librustc_back/mipsel.rs
index 3eea0a0..dc1e770 100644
--- a/src/librustc_back/mipsel.rs
+++ b/src/librustc_back/mipsel.rs
@@ -51,17 +51,17 @@ pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs
           abi::OsAndroid => {
             "e-p:32:32:32\
                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\
                 -f32:32:32-f64:64:64\
                 -v64:64:64-v128:64:128\
                 -a:0:64-n32".to_string()
           }
 
-          abi::OsFreebsd | abi::OsDragonfly => {
+          abi::OsFreebsd | abi::OsDragonfly | abi::OsBitrig => {
             "e-p:32:32:32\
                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\
                 -f32:32:32-f64:64:64\
                 -v64:64:64-v128:64:128\
                 -a:0:64-n32".to_string()
           }
         },
 
diff --git a/src/librustc_back/rpath.rs b/src/librustc_back/rpath.rs
index db1dfa6..ece4bef 100644
--- a/src/librustc_back/rpath.rs
+++ b/src/librustc_back/rpath.rs
@@ -210,17 +210,17 @@ mod test {
             is_like_osx: false,
             realpath: |p| Ok(p.clone())
         };
         let res = get_rpath_relative_to_output(config, &Path::new("lib/libstd.so"));
         assert_eq!(res, "$ORIGIN/../lib");
     }
 
     #[test]
-    #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+    #[cfg(any(target_os = "freebsd", target_os = "dragonfly", target_os = "bitrig"))]
     fn test_rpath_relative() {
         let config = &mut RPathConfig {
             used_crates: Vec::new(),
             has_rpath: true,
             is_like_osx: false,
             out_filename: Path::new("bin/rustc"),
             get_install_prefix_lib_path: || panic!(),
             realpath: |p| Ok(p.clone())
diff --git a/src/librustc_back/target/bitrig_base.rs b/src/librustc_back/target/bitrig_base.rs
new file mode 100644
index 0000000..6e5a48c
--- /dev/null
+++ b/src/librustc_back/target/bitrig_base.rs
@@ -0,0 +1,28 @@
+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT
+// file at the top-level directory of this distribution and at
+// http://rust-lang.org/COPYRIGHT.
+//
+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
+// option. This file may not be copied, modified, or distributed
+// except according to those terms.
+
+use target::TargetOptions;
+use std::default::Default;
+
+pub fn opts() -> TargetOptions {
+    TargetOptions {
+        linker: "cc".to_string(),
+        dynamic_linking: true,
+        executables: true,
+        morestack: false,
+        linker_is_gnu: true,
+        has_rpath: true,
+        position_independent_executables: true,
+        pre_link_args: vec!(
+        ),
+
+        .. Default::default()
+    }
+}
diff --git a/src/librustc_back/target/mod.rs b/src/librustc_back/target/mod.rs
index 23c8fc7..286b024 100644
--- a/src/librustc_back/target/mod.rs
+++ b/src/librustc_back/target/mod.rs
@@ -50,16 +50,17 @@ use syntax::{diagnostic, abi};
 use std::default::Default;
 use std::io::fs::PathExtensions;
 
 mod windows_base;
 mod linux_base;
 mod apple_base;
 mod freebsd_base;
 mod dragonfly_base;
+mod bitrig_base;
 
 mod arm_apple_ios;
 mod arm_linux_androideabi;
 mod arm_unknown_linux_gnueabi;
 mod arm_unknown_linux_gnueabihf;
 mod aarch64_unknown_linux_gnu;
 mod i686_apple_darwin;
 mod i386_apple_ios;
@@ -67,16 +68,17 @@ mod i686_pc_windows_gnu;
 mod i686_unknown_dragonfly;
 mod i686_unknown_linux_gnu;
 mod mips_unknown_linux_gnu;
 mod mipsel_unknown_linux_gnu;
 mod x86_64_apple_darwin;
 mod x86_64_pc_windows_gnu;
 mod x86_64_unknown_freebsd;
 mod x86_64_unknown_dragonfly;
+mod x86_64_unknown_bitrig;
 mod x86_64_unknown_linux_gnu;
 
 /// Everything `rustc` knows about how to compile for a specific target.
 ///
 /// Every field here must be specified, and has no default value.
 #[derive(Clone, Show)]
 pub struct Target {
     /// [Data layout](http://llvm.org/docs/LangRef.html#data-layout) to pass to LLVM.
@@ -340,16 +342,18 @@ impl Target {
             arm_unknown_linux_gnueabihf,
             aarch64_unknown_linux_gnu,
 
             x86_64_unknown_freebsd,
 
             i686_unknown_dragonfly,
             x86_64_unknown_dragonfly,
 
+            x86_64_unknown_bitrig,
+
             x86_64_apple_darwin,
             i686_apple_darwin,
             i386_apple_ios,
             arm_apple_ios,
 
             x86_64_pc_windows_gnu,
             i686_pc_windows_gnu
         );
diff --git a/src/librustc_back/target/x86_64_unknown_bitrig.rs b/src/librustc_back/target/x86_64_unknown_bitrig.rs
new file mode 100644
index 0000000..bc4f8b6
--- /dev/null
+++ b/src/librustc_back/target/x86_64_unknown_bitrig.rs
@@ -0,0 +1,28 @@
+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT
+// file at the top-level directory of this distribution and at
+// http://rust-lang.org/COPYRIGHT.
+//
+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
+// option. This file may not be copied, modified, or distributed
+// except according to those terms.
+
+use target::Target;
+
+pub fn target() -> Target {
+    let mut base = super::bitrig_base::opts();
+    base.pre_link_args.push("-m64".to_string());
+
+    Target {
+        data_layout: "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\
+                     f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\
+                     s0:64:64-f80:128:128-n8:16:32:64-S128".to_string(),
+        llvm_target: "x86_64-unknown-bitrig".to_string(),
+        target_endian: "little".to_string(),
+        target_word_size: "64".to_string(),
+        arch: "x86_64".to_string(),
+        target_os: "bitrig".to_string(),
+        options: base,
+    }
+}
diff --git a/src/librustc_back/x86.rs b/src/librustc_back/x86.rs
index 52c0716..770a8e1 100644
--- a/src/librustc_back/x86.rs
+++ b/src/librustc_back/x86.rs
@@ -40,20 +40,17 @@ pub fn get_target_strs(target_triple: String, target_os: abi::Os)
 
           abi::OsLinux => {
             "e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32".to_string()
           }
           abi::OsAndroid => {
             "e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32".to_string()
           }
 
-          abi::OsFreebsd => {
-            "e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32".to_string()
-          }
-          abi::OsDragonfly => {
+          abi::OsFreebsd | abi::OsDragonfly | abi::OsBitrig => {
             "e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32".to_string()
           }
 
         },
 
         target_triple: target_triple,
 
         cc_args: vec!("-m32".to_string()),
diff --git a/src/librustc_back/x86_64.rs b/src/librustc_back/x86_64.rs
index cbb288a..dffbb96 100644
--- a/src/librustc_back/x86_64.rs
+++ b/src/librustc_back/x86_64.rs
@@ -42,22 +42,17 @@ pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs
                 s0:64:64-f80:128:128-n8:16:32:64-S128".to_string()
           }
           abi::OsAndroid => {
             "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\
                 f32:32:32-f64:64:64-v64:64:64-v128:128:128-a:0:64-\
                 s0:64:64-f80:128:128-n8:16:32:64-S128".to_string()
           }
 
-          abi::OsFreebsd => {
-            "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\
-                f32:32:32-f64:64:64-v64:64:64-v128:128:128-a:0:64-\
-                s0:64:64-f80:128:128-n8:16:32:64-S128".to_string()
-          }
-          abi::OsDragonfly => {
+          abi::OsFreebsd | abi::OsDragonfly | abi::OsBitrig => {
             "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\
                 f32:32:32-f64:64:64-v64:64:64-v128:128:128-a:0:64-\
                 s0:64:64-f80:128:128-n8:16:32:64-S128".to_string()
           }
 
         },
 
         target_triple: target_triple,
diff --git a/src/librustdoc/flock.rs b/src/librustdoc/flock.rs
index dcc9011..e07145a 100644
--- a/src/librustdoc/flock.rs
+++ b/src/librustdoc/flock.rs
@@ -58,17 +58,17 @@ mod imp {
         }
 
         pub const F_UNLCK: libc::c_short = 2;
         pub const F_WRLCK: libc::c_short = 3;
         pub const F_SETLK: libc::c_int = 12;
         pub const F_SETLKW: libc::c_int = 13;
     }
 
-    #[cfg(target_os = "dragonfly")]
+    #[cfg(any(target_os = "dragonfly", target_os = "bitrig"))]
     mod os {
         use libc;
 
         pub struct flock {
             pub l_start: libc::off_t,
             pub l_len: libc::off_t,
             pub l_pid: libc::pid_t,
             pub l_type: libc::c_short,
diff --git a/src/libstd/dynamic_lib.rs b/src/libstd/dynamic_lib.rs
index 2d013a8..bfd69c5 100644
--- a/src/libstd/dynamic_lib.rs
+++ b/src/libstd/dynamic_lib.rs
@@ -175,34 +175,36 @@ mod test {
                    expected_result, result)
         }
     }
 
     #[test]
     #[cfg(any(target_os = "linux",
               target_os = "macos",
               target_os = "freebsd",
-              target_os = "dragonfly"))]
+              target_os = "dragonfly",
+              target_os = "bitrig"))]
     fn test_errors_do_not_crash() {
         // Open /dev/null as a library to get an error, and make sure
         // that only causes an error, and not a crash.
         let path = Path::new("/dev/null");
         match DynamicLibrary::open(Some(&path)) {
             Err(_) => {}
             Ok(_) => panic!("Successfully opened the empty library.")
         }
     }
 }
 
 #[cfg(any(target_os = "linux",
           target_os = "android",
           target_os = "macos",
           target_os = "ios",
           target_os = "freebsd",
-          target_os = "dragonfly"))]
+          target_os = "dragonfly",
+          target_os = "bitrig"))]
 pub mod dl {
     pub use self::Rtld::*;
     use prelude::v1::*;
 
     use ffi::{self, CString};
     use str;
     use libc;
     use ptr;
diff --git a/src/libstd/os.rs b/src/libstd/os.rs
index cef85c2..de226b5 100644
--- a/src/libstd/os.rs
+++ b/src/libstd/os.rs
@@ -686,17 +686,18 @@ fn real_args_as_bytes() -> Vec<Vec<u8>> {
     }
 
     res
 }
 
 #[cfg(any(target_os = "linux",
           target_os = "android",
           target_os = "freebsd",
-          target_os = "dragonfly"))]
+          target_os = "dragonfly",
+          target_os = "bitrig"))]
 fn real_args_as_bytes() -> Vec<Vec<u8>> {
     use rt;
     rt::args::clone().unwrap_or_else(|| vec![])
 }
 
 #[cfg(not(windows))]
 fn real_args() -> Vec<String> {
     real_args_as_bytes().into_iter()
@@ -1325,16 +1326,47 @@ pub mod consts {
     /// platform: in this case, the empty string.
     pub const EXE_SUFFIX: &'static str = "";
 
     /// Specifies the file extension, if any, used for executable binaries
     /// on this platform: in this case, the empty string.
     pub const EXE_EXTENSION: &'static str = "";
 }
 
+#[cfg(target_os = "bitrig")]
+pub mod consts {
+    pub use os::arch_consts::ARCH;
+
+    pub const FAMILY: &'static str = "unix";
+
+    /// A string describing the specific operating system in use: in this
+    /// case, `bitrig`.
+    pub const SYSNAME: &'static str = "bitrig";
+
+    /// Specifies the filename prefix used for shared libraries on this
+    /// platform: in this case, `lib`.
+    pub const DLL_PREFIX: &'static str = "lib";
+
+    /// Specifies the filename suffix used for shared libraries on this
+    /// platform: in this case, `.so`.
+    pub const DLL_SUFFIX: &'static str = ".so";
+
+    /// Specifies the file extension used for shared libraries on this
+    /// platform that goes after the dot: in this case, `so`.
+    pub const DLL_EXTENSION: &'static str = "so";
+
+    /// Specifies the filename suffix used for executable binaries on this
+    /// platform: in this case, the empty string.
+    pub const EXE_SUFFIX: &'static str = "";
+
+    /// Specifies the file extension, if any, used for executable binaries
+    /// on this platform: in this case, the empty string.
+    pub const EXE_EXTENSION: &'static str = "";
+}
+
 #[cfg(target_os = "android")]
 pub mod consts {
     pub use os::arch_consts::ARCH;
 
     pub const FAMILY: &'static str = "unix";
 
     /// A string describing the specific operating system in use: in this
     /// case, `android`.
diff --git a/src/libstd/rt/args.rs b/src/libstd/rt/args.rs
index 86abacb..4d00af8 100644
--- a/src/libstd/rt/args.rs
+++ b/src/libstd/rt/args.rs
@@ -37,17 +37,18 @@ pub fn take() -> Option<Vec<Vec<u8>>> { imp::take() }
 pub fn put(args: Vec<Vec<u8>>) { imp::put(args) }
 
 /// Make a clone of the global arguments.
 pub fn clone() -> Option<Vec<Vec<u8>>> { imp::clone() }
 
 #[cfg(any(target_os = "linux",
           target_os = "android",
           target_os = "freebsd",
-          target_os = "dragonfly"))]
+          target_os = "dragonfly",
+          target_os = "bitrig"))]
 mod imp {
     use prelude::v1::*;
 
     use libc;
     use mem;
     use ffi;
 
     use sync::{StaticMutex, MUTEX_INIT};
diff --git a/src/libstd/rt/libunwind.rs b/src/libstd/rt/libunwind.rs
index 7cc39d7..946e25f 100644
--- a/src/libstd/rt/libunwind.rs
+++ b/src/libstd/rt/libunwind.rs
@@ -101,16 +101,20 @@ extern {}
 #[cfg(target_os = "android")]
 #[link(name = "gcc")]
 extern {}
 
 #[cfg(target_os = "dragonfly")]
 #[link(name = "gcc_pic")]
 extern {}
 
+#[cfg(target_os = "bitrig")]
+#[link(name = "c++abi")]
+extern {}
+
 extern "C" {
     // iOS on armv7 uses SjLj exceptions and requires to link
     // against corresponding routine (..._SjLj_...)
     #[cfg(not(all(target_os = "ios", target_arch = "arm")))]
     pub fn _Unwind_RaiseException(exception: *mut _Unwind_Exception)
                                   -> _Unwind_Reason_Code;
 
     #[cfg(all(target_os = "ios", target_arch = "arm"))]
diff --git a/src/libstd/rtdeps.rs b/src/libstd/rtdeps.rs
index 862808a..6814806 100644
--- a/src/libstd/rtdeps.rs
+++ b/src/libstd/rtdeps.rs
@@ -34,17 +34,17 @@ extern {}
 #[link(name = "log")]
 extern {}
 
 #[cfg(target_os = "freebsd")]
 #[link(name = "execinfo")]
 #[link(name = "pthread")]
 extern {}
 
-#[cfg(target_os = "dragonfly")]
+#[cfg(any(target_os = "dragonfly", target_os = "bitrig"))]
 #[link(name = "pthread")]
 extern {}
 
 #[cfg(target_os = "macos")]
 #[link(name = "System")]
 extern {}
 
 #[cfg(target_os = "ios")]
diff --git a/src/libstd/sys/common/net.rs b/src/libstd/sys/common/net.rs
index 902942d..fa2f6cb 100644
--- a/src/libstd/sys/common/net.rs
+++ b/src/libstd/sys/common/net.rs
@@ -679,30 +679,34 @@ impl TcpStream {
         let ret = setsockopt(self.fd(), libc::SOL_SOCKET, libc::SO_KEEPALIVE,
                              seconds.is_some() as libc::c_int);
         match seconds {
             Some(n) => ret.and_then(|()| self.set_tcp_keepalive(n)),
             None => ret,
         }
     }
 
-    #[cfg(any(target_os = "macos", target_os = "ios"))]
+    #[cfg(any(target_os = "macos", 
+              target_os = "ios",
+              target_os = "bitrig"))]
     fn set_tcp_keepalive(&mut self, seconds: uint) -> IoResult<()> {
         setsockopt(self.fd(), libc::IPPROTO_TCP, libc::TCP_KEEPALIVE,
                    seconds as libc::c_int)
     }
-    #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+    #[cfg(any(target_os = "freebsd", 
+              target_os = "dragonfly"))]
     fn set_tcp_keepalive(&mut self, seconds: uint) -> IoResult<()> {
         setsockopt(self.fd(), libc::IPPROTO_TCP, libc::TCP_KEEPIDLE,
                    seconds as libc::c_int)
     }
     #[cfg(not(any(target_os = "macos",
                   target_os = "ios",
                   target_os = "freebsd",
-                  target_os = "dragonfly")))]
+                  target_os = "dragonfly",
+                  target_os = "bitrig")))]
     fn set_tcp_keepalive(&mut self, _seconds: uint) -> IoResult<()> {
         Ok(())
     }
 
     #[cfg(target_os = "linux")]
     fn lock_nonblocking(&self) {}
 
     #[cfg(not(target_os = "linux"))]
diff --git a/src/libstd/sys/common/stack.rs b/src/libstd/sys/common/stack.rs
index ce5ab67..51f0a93 100644
--- a/src/libstd/sys/common/stack.rs
+++ b/src/libstd/sys/common/stack.rs
@@ -184,21 +184,28 @@ pub unsafe fn record_sp_limit(limit: uint) {
     }
     #[cfg(all(target_arch = "x86_64", target_os = "windows"))] #[inline(always)]
     unsafe fn target_record_sp_limit(_: uint) {
     }
     #[cfg(all(target_arch = "x86_64", target_os = "freebsd"))] #[inline(always)]
     unsafe fn target_record_sp_limit(limit: uint) {
         asm!("movq $0, %fs:24" :: "r"(limit) :: "volatile")
     }
-    #[cfg(all(target_arch = "x86_64", target_os = "dragonfly"))] #[inline(always)]
+    #[cfg(all(target_arch = "x86_64", target_os = "dragonfly"))]
+    #[inline(always)]
     unsafe fn target_record_sp_limit(limit: uint) {
         asm!("movq $0, %fs:32" :: "r"(limit) :: "volatile")
     }
 
+    #[cfg(target_os = "bitrig")]
+    #[inline(always)]
+    unsafe fn target_record_sp_limit(limit: uint) {
+        // segmented stacks are disabled
+    }
+
     // x86
     #[cfg(all(target_arch = "x86",
               any(target_os = "macos", target_os = "ios")))]
     #[inline(always)]
     unsafe fn target_record_sp_limit(limit: uint) {
         asm!("movl $$0x48+90*4, %eax
               movl $0, %gs:(%eax)" :: "r"(limit) : "eax" : "volatile")
     }
@@ -270,22 +277,28 @@ pub unsafe fn get_sp_limit() -> uint {
         return 1024;
     }
     #[cfg(all(target_arch = "x86_64", target_os = "freebsd"))] #[inline(always)]
     unsafe fn target_get_sp_limit() -> uint {
         let limit;
         asm!("movq %fs:24, $0" : "=r"(limit) ::: "volatile");
         return limit;
     }
-    #[cfg(all(target_arch = "x86_64", target_os = "dragonfly"))] #[inline(always)]
+    #[cfg(all(target_arch = "x86_64", target_os = "dragonfly"))]
+    #[inline(always)]
     unsafe fn target_get_sp_limit() -> uint {
         let limit;
         asm!("movq %fs:32, $0" : "=r"(limit) ::: "volatile");
         return limit;
     }
+    #[cfg(target_os = "bitrig")]
+    #[inline(always)]
+    unsafe fn target_get_sp_limit() -> uint {
+      return 2048;
+    }
 
 
     // x86
     #[cfg(all(target_arch = "x86",
               any(target_os = "macos", target_os = "ios")))]
     #[inline(always)]
     unsafe fn target_get_sp_limit() -> uint {
         let limit;
diff --git a/src/libstd/sys/unix/c.rs b/src/libstd/sys/unix/c.rs
index cc66187..9f38068 100644
--- a/src/libstd/sys/unix/c.rs
+++ b/src/libstd/sys/unix/c.rs
@@ -18,49 +18,52 @@ pub use self::signal::{sigaction, siginfo, sigset_t};
 pub use self::signal::{SA_ONSTACK, SA_RESTART, SA_RESETHAND, SA_NOCLDSTOP};
 pub use self::signal::{SA_NODEFER, SA_NOCLDWAIT, SA_SIGINFO, SIGCHLD};
 
 use libc;
 
 #[cfg(any(target_os = "macos",
           target_os = "ios",
           target_os = "freebsd",
-          target_os = "dragonfly"))]
+          target_os = "dragonfly",
+          target_os = "bitrig"))]
 pub const FIONBIO: libc::c_ulong = 0x8004667e;
 #[cfg(any(all(target_os = "linux",
               any(target_arch = "x86",
                   target_arch = "x86_64",
                   target_arch = "arm",
                   target_arch = "aarch64")),
           target_os = "android"))]
 pub const FIONBIO: libc::c_ulong = 0x5421;
 #[cfg(all(target_os = "linux",
           any(target_arch = "mips", target_arch = "mipsel")))]
 pub const FIONBIO: libc::c_ulong = 0x667e;
 
 #[cfg(any(target_os = "macos",
           target_os = "ios",
           target_os = "freebsd",
-          target_os = "dragonfly"))]
+          target_os = "dragonfly",
+          target_os = "bitrig"))]
 pub const FIOCLEX: libc::c_ulong = 0x20006601;
 #[cfg(any(all(target_os = "linux",
               any(target_arch = "x86",
                   target_arch = "x86_64",
                   target_arch = "arm",
                   target_arch = "aarch64")),
           target_os = "android"))]
 pub const FIOCLEX: libc::c_ulong = 0x5451;
 #[cfg(all(target_os = "linux",
           any(target_arch = "mips", target_arch = "mipsel")))]
 pub const FIOCLEX: libc::c_ulong = 0x6601;
 
 #[cfg(any(target_os = "macos",
           target_os = "ios",
           target_os = "freebsd",
-          target_os = "dragonfly"))]
+          target_os = "dragonfly",
+          target_os = "bitrig"))]
 pub const MSG_DONTWAIT: libc::c_int = 0x80;
 #[cfg(any(target_os = "linux", target_os = "android"))]
 pub const MSG_DONTWAIT: libc::c_int = 0x40;
 
 pub const WNOHANG: libc::c_int = 1;
 
 extern {
     pub fn gettimeofday(timeval: *mut libc::timeval,
@@ -102,16 +105,17 @@ mod select {
     pub fn fd_set(set: &mut fd_set, fd: i32) {
         set.fds_bits[(fd / 32) as uint] |= 1 << ((fd % 32) as uint);
     }
 }
 
 #[cfg(any(target_os = "android",
           target_os = "freebsd",
           target_os = "dragonfly",
+          target_os = "bitrig",
           target_os = "linux"))]
 mod select {
     use uint;
     use libc;
 
     pub const FD_SETSIZE: uint = 1024;
 
     #[repr(C)]
@@ -264,8 +268,46 @@ mod signal {
 
     #[repr(C)]
     pub struct sigaction {
         pub sa_handler: extern fn(libc::c_int),
         pub sa_flags: libc::c_int,
         pub sa_mask: sigset_t,
     }
 }
+
+#[cfg(target_os = "bitrig")]
+mod signal {
+    use libc;
+
+    pub const SA_ONSTACK: libc::c_int = 0x0001;
+    pub const SA_RESTART: libc::c_int = 0x0002;
+    pub const SA_RESETHAND: libc::c_int = 0x0004;
+    pub const SA_NOCLDSTOP: libc::c_int = 0x0008;
+    pub const SA_NODEFER: libc::c_int = 0x0010;
+    pub const SA_NOCLDWAIT: libc::c_int = 0x0020;
+    pub const SA_SIGINFO: libc::c_int = 0x0040;
+    pub const SIGCHLD: libc::c_int = 20;
+
+    pub type sigset_t = libc::c_uint;
+
+    // This structure has more fields, but we're not all that interested in
+    // them.
+    #[repr(C)]
+    pub struct siginfo {
+        pub si_signo: libc::c_int,
+        pub si_code: libc::c_int,
+        pub si_errno: libc::c_int,
+        // FIXME: Bitrig has a crazy union here in the siginfo, I think this
+        // layout will still work tho.  The status might be off by the size of
+        // a clock_t by my reading, but we can fix this later.
+        pub pid: libc::pid_t,
+        pub uid: libc::uid_t,
+        pub status: libc::c_int,
+    }
+
+    #[repr(C)]
+    pub struct sigaction {
+        pub sa_handler: extern fn(libc::c_int),
+        pub sa_mask: sigset_t,
+        pub sa_flags: libc::c_int,
+    }
+}
diff --git a/src/libstd/sys/unix/fs.rs b/src/libstd/sys/unix/fs.rs
index c53f9d2..f42d064 100644
--- a/src/libstd/sys/unix/fs.rs
+++ b/src/libstd/sys/unix/fs.rs
@@ -285,16 +285,43 @@ pub fn link(src: &Path, dst: &Path) -> IoResult<()> {
     let dst = cstr(dst);
     mkerr_libc(unsafe { libc::link(src.as_ptr(), dst.as_ptr()) })
 }
 
 fn mkstat(stat: &libc::stat) -> FileStat {
     // FileStat times are in milliseconds
     fn mktime(secs: u64, nsecs: u64) -> u64 { secs * 1000 + nsecs / 1000000 }
 
+    #[cfg(target_os = "bitrig")]
+    fn ctime(stat: &libc::stat) -> u64 { 
+      mktime(stat.st_ctim.tv_sec as u64, stat.st_ctim.tv_nsec as u64)
+    }
+    #[cfg(not(target_os = "bitrig"))]
+    fn ctime(stat: &libc::stat) -> u64 { 
+      mktime(stat.st_ctime as u64, stat.st_ctime_nsec as u64) 
+    }
+
+    #[cfg(target_os = "bitrig")]
+    fn atime(stat: &libc::stat) -> u64 { 
+      mktime(stat.st_atim.tv_sec as u64, stat.st_atim.tv_nsec as u64)
+    }
+    #[cfg(not(target_os = "bitrig"))]
+    fn atime(stat: &libc::stat) -> u64 { 
+      mktime(stat.st_atime as u64, stat.st_atime_nsec as u64)
+    }
+
+    #[cfg(target_os = "bitrig")]
+    fn mtime(stat: &libc::stat) -> u64 { 
+      mktime(stat.st_mtim.tv_sec as u64, stat.st_mtim.tv_nsec as u64)
+    }
+    #[cfg(not(target_os = "bitrig"))]
+    fn mtime(stat: &libc::stat) -> u64 { 
+      mktime(stat.st_mtime as u64, stat.st_mtime_nsec as u64)
+    }
+
     #[cfg(not(any(target_os = "linux", target_os = "android")))]
     fn flags(stat: &libc::stat) -> u64 { stat.st_flags as u64 }
     #[cfg(any(target_os = "linux", target_os = "android"))]
     fn flags(_stat: &libc::stat) -> u64 { 0 }
 
     #[cfg(not(any(target_os = "linux", target_os = "android")))]
     fn gen(stat: &libc::stat) -> u64 { stat.st_gen as u64 }
     #[cfg(any(target_os = "linux", target_os = "android"))]
@@ -306,19 +333,19 @@ fn mkstat(stat: &libc::stat) -> FileStat {
             libc::S_IFREG => io::FileType::RegularFile,
             libc::S_IFDIR => io::FileType::Directory,
             libc::S_IFIFO => io::FileType::NamedPipe,
             libc::S_IFBLK => io::FileType::BlockSpecial,
             libc::S_IFLNK => io::FileType::Symlink,
             _ => io::FileType::Unknown,
         },
         perm: FilePermission::from_bits_truncate(stat.st_mode as u32),
-        created: mktime(stat.st_ctime as u64, stat.st_ctime_nsec as u64),
-        modified: mktime(stat.st_mtime as u64, stat.st_mtime_nsec as u64),
-        accessed: mktime(stat.st_atime as u64, stat.st_atime_nsec as u64),
+        created: ctime(stat),
+        modified: mtime(stat),
+        accessed: atime(stat),
         unstable: UnstableFileStat {
             device: stat.st_dev as u64,
             inode: stat.st_ino as u64,
             rdev: stat.st_rdev as u64,
             nlink: stat.st_nlink as u64,
             uid: stat.st_uid as u64,
             gid: stat.st_gid as u64,
             blksize: stat.st_blksize as u64,
diff --git a/src/libstd/sys/unix/os.rs b/src/libstd/sys/unix/os.rs
index 175c4e2..066bbc7 100644
--- a/src/libstd/sys/unix/os.rs
+++ b/src/libstd/sys/unix/os.rs
@@ -35,16 +35,26 @@ pub fn errno() -> int {
         extern {
             fn __error() -> *const c_int;
         }
         unsafe {
             __error()
         }
     }
 
+    #[cfg(target_os = "bitrig")]
+    fn errno_location() -> *const c_int {
+        extern {
+            fn __errno() -> *const c_int;
+        }
+        unsafe {
+            __errno()
+        }
+    }
+
     #[cfg(target_os = "dragonfly")]
     fn errno_location() -> *const c_int {
         extern {
             fn __dfly_error() -> *const c_int;
         }
         unsafe {
             __dfly_error()
         }
@@ -66,17 +76,18 @@ pub fn errno() -> int {
 }
 
 /// Get a detailed string description for the given error number
 pub fn error_string(errno: i32) -> String {
     #[cfg(any(target_os = "macos",
               target_os = "ios",
               target_os = "android",
               target_os = "freebsd",
-              target_os = "dragonfly"))]
+              target_os = "dragonfly",
+              target_os = "bitrig"))]
     fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: libc::size_t)
                   -> c_int {
         extern {
             fn strerror_r(errnum: c_int, buf: *mut c_char,
                           buflen: libc::size_t) -> c_int;
         }
         unsafe {
             strerror_r(errnum, buf, buflen)
@@ -199,16 +210,31 @@ pub fn load_self() -> Option<Vec<u8>> {
     use std::io;
 
     match io::fs::readlink(&Path::new("/proc/curproc/file")) {
         Ok(path) => Some(path.into_vec()),
         Err(..) => None
     }
 }
 
+#[cfg(target_os = "bitrig")]
+pub fn load_self() -> Option<Vec<u8>> {
+    extern {
+        fn __load_self() -> *const c_char;
+    }
+    unsafe {
+        let v = __load_self();
+        if v.is_null() {
+            None
+        } else {
+            Some(ffi::c_str_to_bytes(&v).to_vec())
+        }
+    }
+}
+
 #[cfg(any(target_os = "linux", target_os = "android"))]
 pub fn load_self() -> Option<Vec<u8>> {
     use std::io;
 
     match io::fs::readlink(&Path::new("/proc/self/exe")) {
         Ok(path) => Some(path.into_vec()),
         Err(..) => None
     }
diff --git a/src/libstd/sys/unix/process.rs b/src/libstd/sys/unix/process.rs
index 1357bbd..46800d0 100644
--- a/src/libstd/sys/unix/process.rs
+++ b/src/libstd/sys/unix/process.rs
@@ -598,17 +598,18 @@ fn translate_status(status: c_int) -> ProcessExit {
         pub fn WIFEXITED(status: i32) -> bool { (status & 0xff) == 0 }
         pub fn WEXITSTATUS(status: i32) -> i32 { (status >> 8) & 0xff }
         pub fn WTERMSIG(status: i32) -> i32 { status & 0x7f }
     }
 
     #[cfg(any(target_os = "macos",
               target_os = "ios",
               target_os = "freebsd",
-              target_os = "dragonfly"))]
+              target_os = "dragonfly",
+              target_os = "bitrig"))]
     mod imp {
         pub fn WIFEXITED(status: i32) -> bool { (status & 0x7f) == 0 }
         pub fn WEXITSTATUS(status: i32) -> i32 { status >> 8 }
         pub fn WTERMSIG(status: i32) -> i32 { status & 0o177 }
     }
 
     if imp::WIFEXITED(status) {
         ExitStatus(imp::WEXITSTATUS(status) as int)
diff --git a/src/libstd/sys/unix/sync.rs b/src/libstd/sys/unix/sync.rs
index 1d8a59d..d93d7b8 100644
--- a/src/libstd/sys/unix/sync.rs
+++ b/src/libstd/sys/unix/sync.rs
@@ -39,17 +39,19 @@ extern {
     pub fn pthread_rwlock_destroy(lock: *mut pthread_rwlock_t) -> libc::c_int;
     pub fn pthread_rwlock_rdlock(lock: *mut pthread_rwlock_t) -> libc::c_int;
     pub fn pthread_rwlock_tryrdlock(lock: *mut pthread_rwlock_t) -> libc::c_int;
     pub fn pthread_rwlock_wrlock(lock: *mut pthread_rwlock_t) -> libc::c_int;
     pub fn pthread_rwlock_trywrlock(lock: *mut pthread_rwlock_t) -> libc::c_int;
     pub fn pthread_rwlock_unlock(lock: *mut pthread_rwlock_t) -> libc::c_int;
 }
 
-#[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+#[cfg(any(target_os = "freebsd",
+          target_os = "dragonfly",
+          target_os = "bitrig"))]
 mod os {
     use libc;
 
     pub type pthread_mutex_t = *mut libc::c_void;
     pub type pthread_cond_t = *mut libc::c_void;
     pub type pthread_rwlock_t = *mut libc::c_void;
 
     pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = 0 as *mut _;
diff --git a/src/libstd/time/mod.rs b/src/libstd/time/mod.rs
index d6c94f2..b10ee1a 100644
--- a/src/libstd/time/mod.rs
+++ b/src/libstd/time/mod.rs
@@ -63,17 +63,18 @@ fn precise_time_ns() -> u64 {
     }
 }
 
 #[cfg(all(unix, not(target_os = "macos"), not(target_os = "ios")))]
 mod imp {
     use libc::{c_int, timespec};
 
     // Apparently android provides this in some other library?
-    #[cfg(not(target_os = "android"))]
+    // Bitrig's RT extensions are in the C library, not a separate librt
+    #[cfg(not(any(target_os = "android", target_os = "bitrig")))]
     #[link(name = "rt")]
     extern {}
 
     extern {
         pub fn clock_gettime(clk_id: c_int, tp: *mut timespec) -> c_int;
     }
 
 }
diff --git a/src/libsyntax/abi.rs b/src/libsyntax/abi.rs
index 09235ee..99c3cb6 100644
--- a/src/libsyntax/abi.rs
+++ b/src/libsyntax/abi.rs
@@ -19,16 +19,17 @@ use std::fmt;
 pub enum Os {
     OsWindows,
     OsMacos,
     OsLinux,
     OsAndroid,
     OsFreebsd,
     OsiOS,
     OsDragonfly,
+    OsBitrig,
 }
 
 #[derive(PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Clone, Copy)]
 pub enum Abi {
     // NB: This ordering MUST match the AbiDatas array below.
     // (This is ensured by the test indices_are_correct().)
 
     // Single platform ABIs come first (`for_arch()` relies on this)
@@ -141,17 +142,18 @@ impl fmt::String for Os {
     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
         match *self {
             OsLinux => "linux".fmt(f),
             OsWindows => "windows".fmt(f),
             OsMacos => "macos".fmt(f),
             OsiOS => "ios".fmt(f),
             OsAndroid => "android".fmt(f),
             OsFreebsd => "freebsd".fmt(f),
-            OsDragonfly => "dragonfly".fmt(f)
+            OsDragonfly => "dragonfly".fmt(f),
+            OsBitrig => "bitrig".fmt(f)
         }
     }
 }
 
 #[allow(non_snake_case)]
 #[test]
 fn lookup_Rust() {
     let abi = lookup("Rust");
diff --git a/src/rt/arch/x86_64/morestack.S b/src/rt/arch/x86_64/morestack.S
index c82da57..cf2b9b9 100644
--- a/src/rt/arch/x86_64/morestack.S
+++ b/src/rt/arch/x86_64/morestack.S
@@ -10,23 +10,23 @@
 #if defined(__APPLE__)
 #define MORESTACK               ___morestack
 #else
 #define MORESTACK               __morestack
 #endif
 
 #if defined(__APPLE__)
 #define EXHAUSTED               _rust_stack_exhausted
-#elif defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__)
+#elif defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__) || defined(__Bitrig__)
 #define EXHAUSTED               rust_stack_exhausted@PLT
 #else
 #define EXHAUSTED               rust_stack_exhausted
 #endif
 
-#if defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__)
+#if defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__) || defined(__Bitrig__)
 	.hidden MORESTACK
 #else
 #if defined(__APPLE__)
 	.private_extern MORESTACK
 #endif
 #endif
 
 #ifdef __ELF__
diff --git a/src/rt/rust_builtin.c b/src/rt/rust_builtin.c
index 5dc07f8..6bb8c70 100644
--- a/src/rt/rust_builtin.c
+++ b/src/rt/rust_builtin.c
@@ -65,17 +65,17 @@ timegm(struct tm *tm)
 #endif
 
 #ifdef __APPLE__
 #if (TARGET_OS_IPHONE)
 extern char **environ;
 #endif
 #endif
 
-#if defined(__FreeBSD__) || defined(__linux__) || defined(__ANDROID__) || defined(__DragonFly__)
+#if defined(__FreeBSD__) || defined(__linux__) || defined(__ANDROID__) || defined(__DragonFly__) || (__Bitrig__)
 extern char **environ;
 #endif
 
 #if defined(__WIN32__)
 char**
 rust_env_pairs() {
     return 0;
 }
@@ -332,16 +332,58 @@ rust_unset_sigprocmask() {
 
 #if defined(__DragonFly__)
 #include <errno.h>
 // In DragonFly __error() is an inline function and as such
 // no symbol exists for it.
 int *__dfly_error(void) { return __error(); }
 #endif
 
+#if defined(__Bitrig__)
+//NOTE: borrowed from semarie's openbsd patch (http://bit.ly/1thduJm)
+#include <sys/param.h>
+#include <sys/sysctl.h>
+#include <limits.h>
+
+const char * __load_self() {
+  static char *self = NULL;
+  if (self == NULL) {
+    int mib[4];
+    char **argv = NULL;
+    size_t argv_len;
+
+    /* initialize mib */
+    mib[0] = CTL_KERN;
+    mib[1] = KERN_PROC_ARGS;
+    mib[2] = getpid();
+    mib[3] = KERN_PROC_ARGV;
+
+    /* request KERN_PROC_ARGV size */
+    argv_len = 0;
+    if (sysctl(mib, 4, NULL, &argv_len, NULL, 0) == -1)
+      return NULL;
+
+    /* allocate buffer to receive the values */
+    if ((argv = malloc(argv_len)) == NULL)
+      return NULL;
+
+    /* request the realpath if possible */
+    if ((argv[0] != NUL) && ((*argv[0] == '.') || (*argv[0] == '/') || (strstr(argv[0], "/") != NULL)))
+      self = realpath(argv[0], NULL);
+    else
+      self = NULL;
+
+    /* cleanup */
+    free(argv);
+  }
+
+  return self;
+}
+#endif
+
 //
 // Local Variables:
 // mode: C++
 // fill-column: 78;
 // indent-tabs-mode: nil
 // c-basic-offset: 4
 // buffer-file-coding-system: utf-8-unix
 // End:
diff --git a/src/test/run-pass/dupe-first-attr.rc b/src/test/run-pass/dupe-first-attr.rc
index 30d6b93..eb66423 100644
--- a/src/test/run-pass/dupe-first-attr.rc
+++ b/src/test/run-pass/dupe-first-attr.rc
@@ -21,12 +21,15 @@ mod hello;
 mod hello;
 
 #[cfg(target_os = "freebsd")]
 mod hello;
 
 #[cfg(target_os = "dragonfly")]
 mod hello;
 
+#[cfg(target_os = "bitrig")]
+mod hello;
+
 #[cfg(target_os = "android")]
 mod hello;
 
 pub fn main() { }
diff --git a/src/test/run-pass/intrinsic-alignment.rs b/src/test/run-pass/intrinsic-alignment.rs
index 52fcaf5..915abf7 100644
--- a/src/test/run-pass/intrinsic-alignment.rs
+++ b/src/test/run-pass/intrinsic-alignment.rs
@@ -36,16 +36,28 @@ mod m {
     pub fn main() {
         unsafe {
             assert_eq!(::rusti::pref_align_of::<u64>(), 8u);
             assert_eq!(::rusti::min_align_of::<u64>(), 8u);
         }
     }
 }
 
+#[cfg(target_os = "bitrig")]
+mod m {
+    #[main]
+    #[cfg(target_arch = "x86_64")]
+    pub fn main() {
+        unsafe {
+            assert_eq!(::rusti::pref_align_of::<u64>(), 8u);
+            assert_eq!(::rusti::min_align_of::<u64>(), 8u);
+        }
+    }
+}
+
 #[cfg(target_os = "windows")]
 mod m {
     #[main]
     #[cfg(target_arch = "x86")]
     pub fn main() {
         unsafe {
             assert_eq!(::rusti::pref_align_of::<u64>(), 8u);
             assert_eq!(::rusti::min_align_of::<u64>(), 8u);
diff --git a/src/test/run-pass/lang-item-public.rs b/src/test/run-pass/lang-item-public.rs
index 81774c7..d4c85c4 100644
--- a/src/test/run-pass/lang-item-public.rs
+++ b/src/test/run-pass/lang-item-public.rs
@@ -32,16 +32,20 @@ extern {}
 #[cfg(target_os = "freebsd")]
 #[link(name = "c")]
 extern {}
 
 #[cfg(target_os = "dragonfly")]
 #[link(name = "c")]
 extern {}
 
+#[cfg(target_os = "bitrig")]
+#[link(name = "c")]
+extern {}
+
 #[cfg(target_os = "macos")]
 #[link(name = "System")]
 extern {}
 
 #[start]
 fn main(_: int, _: *const *const u8) -> int {
     1 % 1
 }
diff --git a/src/test/run-pass/out-of-stack-new-thread-no-split.rs b/src/test/run-pass/out-of-stack-new-thread-no-split.rs
index ce6604d..190ed93 100644
--- a/src/test/run-pass/out-of-stack-new-thread-no-split.rs
+++ b/src/test/run-pass/out-of-stack-new-thread-no-split.rs
@@ -7,16 +7,17 @@
 // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
 // option. This file may not be copied, modified, or distributed
 // except according to those terms.
 
 //ignore-android
 //ignore-freebsd
 //ignore-ios
 //ignore-dragonfly
+//ignore-bitrig
 
 #![feature(asm)]
 
 use std::io::process::Command;
 use std::os;
 use std::thread::Thread;
 
 // lifted from the test module
diff --git a/src/test/run-pass/out-of-stack-no-split.rs b/src/test/run-pass/out-of-stack-no-split.rs
index 7992677..5054dbb 100644
--- a/src/test/run-pass/out-of-stack-no-split.rs
+++ b/src/test/run-pass/out-of-stack-no-split.rs
@@ -8,16 +8,17 @@
 // option. This file may not be copied, modified, or distributed
 // except according to those terms.
 
 //ignore-android
 //ignore-linux
 //ignore-freebsd
 //ignore-ios
 //ignore-dragonfly
+//ignore-bitrig
 
 #![feature(asm)]
 
 use std::io::process::Command;
 use std::os;
 
 // lifted from the test module
 // Inlining to avoid llvm turning the recursive functions into tail calls,
diff --git a/src/test/run-pass/rec-align-u64.rs b/src/test/run-pass/rec-align-u64.rs
index 2794154..da88880 100644
--- a/src/test/run-pass/rec-align-u64.rs
+++ b/src/test/run-pass/rec-align-u64.rs
@@ -49,16 +49,25 @@ mod m {
 
     #[cfg(any(target_arch = "x86_64", target_arch = "arm", target_arch = "aarch64"))]
     pub mod m {
         pub fn align() -> uint { 8u }
         pub fn size() -> uint { 16u }
     }
 }
 
+#[cfg(target_os = "bitrig")]
+mod m {
+    #[cfg(target_arch = "x86_64")]
+    pub mod m {
+        pub fn align() -> uint { 8u }
+        pub fn size() -> uint { 16u }
+    }
+}
+
 #[cfg(target_os = "windows")]
 mod m {
     #[cfg(target_arch = "x86")]
     pub mod m {
         pub fn align() -> uint { 8u }
         pub fn size() -> uint { 16u }
     }
 
diff --git a/src/test/run-pass/x86stdcall.rs b/src/test/run-pass/x86stdcall.rs
index 15d1852..13cab11 100644
--- a/src/test/run-pass/x86stdcall.rs
+++ b/src/test/run-pass/x86stdcall.rs
@@ -29,10 +29,11 @@ pub fn main() {
         assert_eq!(expected, actual);
     }
 }
 
 #[cfg(any(target_os = "macos",
           target_os = "linux",
           target_os = "freebsd",
           target_os = "dragonfly",
+          target_os = "bitrig",
           target_os = "android"))]
 pub fn main() { }
