diff --git a/lib/librthread/tcb.h b/lib/librthread/tcb.h
index 23e5cd9..5c4fb5f 100644
--- a/lib/librthread/tcb.h
+++ b/lib/librthread/tcb.h
@@ -69,56 +69,60 @@ void	__set_tcb(void *);
 /*
  * Small TCB, with TLS data after the TCB.
  * Errno pointer stored in struct pthread
  */
 
 struct thread_control_block {
 	void	*tcb_dtv;		/* internal to the runtime linker */
 	struct	pthread *tcb_thread;
+	void *tcb_segstack; /* used for segmented stacks */
 };
 
 #ifndef THREAD_ERRNOPTR_OFFSET
 # define THREAD_ERRNOPTR_OFFSET	offsetof(struct pthread, errno_ptr)
 #endif
 #define __ERRNOPTR(thread)	\
 	(((int **)(thread))[THREAD_ERRNOPTR_OFFSET / sizeof(int *)])
 #define TCB_ERRNOPTR()	\
 	__ERRNOPTR(TCB_THREAD())
 #define	TCB_INIT(tcb, thread, errnoptr)			\
 	do {						\
 		(tcb)->tcb_thread = (thread);		\
 		__ERRNOPTR(thread) = (errnoptr);	\
+		(tcb)->tcb_segstack = NULL; \
 	} while (0)
 
 
 #elif TLS_VARIANT == 2
 /*
  * Large TCB, with TLS data before the TCB (i.e., negative offsets)
  * Errno pointer stored in the TCB
  */
 
 struct thread_control_block {
 	struct	thread_control_block *__tcb_self;
 	void	*tcb_dtv;		/* internal to the runtime linker */
 	struct	pthread *tcb_thread;
 	int	*__tcb_errno;
+	void *tcb_segstack; /* used for segmented stacks */
 };
 
 #ifdef TCB_GET_MEMBER
 #define TCB_ERRNOPTR()	((int *)TCB_GET_MEMBER(__tcb_errno))
 #else
 #define TCB_ERRNOPTR()	\
 		(((struct thread_control_block *)__get_tcb())->__tcb_errno)
 #endif
 #define	TCB_INIT(tcb, thread, errnoptr)			\
 	do {						\
 		(tcb)->__tcb_self = (tcb);		\
 		(tcb)->tcb_thread = (thread);		\
 		(tcb)->__tcb_errno = (errnoptr);	\
+		(tcb)->tcb_segstack = NULL; \
 	} while (0)
 
 
 #else
 # error "unknown TLS variant"
 #endif
 
 
