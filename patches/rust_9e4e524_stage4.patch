diff --git a/configure b/configure
index ea9320c..e8962b4 100755
--- a/configure
+++ b/configure
@@ -368,16 +368,20 @@ case $CFG_OSTYPE in
     FreeBSD)
         CFG_OSTYPE=unknown-freebsd
         ;;
 
     DragonFly)
         CFG_OSTYPE=unknown-dragonfly
         ;;
 
+    Bitrig)
+        CFG_OSTYPE=unknown-bitrig
+        ;;
+
     Darwin)
         CFG_OSTYPE=apple-darwin
         ;;
 
     MINGW*)
         # msys' `uname` does not print gcc configuration, but prints msys
         # configuration. so we cannot believe `uname -m`:
         # msys1 is always i686 and msys2 is always x86_64.
@@ -722,16 +726,23 @@ fi
 
 # Force freebsd to build with clang; gcc doesn't like us there
 if [ $CFG_OSTYPE = unknown-freebsd ]
 then
     step_msg "on FreeBSD, forcing use of clang"
     CFG_ENABLE_CLANG=1
 fi
 
+# Force bitrig to build with clang; gcc doesn't like us there
+if [ $CFG_OSTYPE = unknown-bitrig ]
+then
+    step_msg "on Bitrig, forcing use of clang"
+    CFG_ENABLE_CLANG=1
+fi
+
 if [ -z "$CFG_ENABLE_CLANG" -a -z "$CFG_GCC" ]
 then
     err "either clang or gcc is required"
 fi
 
 # OS X 10.9, gcc is actually clang. This can cause some confusion in the build
 # system, so if we find that gcc is clang, we should just use clang directly.
 if [ $CFG_OSTYPE = apple-darwin -a -z "$CFG_ENABLE_CLANG" ]
@@ -1093,21 +1104,22 @@ then
     "${CFG_GIT}" submodule update --recursive
     need_ok "git failed"
 
     # NB: this is just for the sake of getting the submodule SHA1 values
     # and status written into the build log.
     msg "git: submodule status"
     "${CFG_GIT}" submodule status --recursive
 
-    msg "git: submodule clobber"
-    "${CFG_GIT}" submodule foreach --recursive git clean -dxf
-    need_ok "git failed"
-    "${CFG_GIT}" submodule foreach --recursive git checkout .
-    need_ok "git failed"
+    # don't clobber so that our patches won't get removed
+    #msg "git: submodule clobber"
+    #"${CFG_GIT}" submodule foreach --recursive git clean -dxf
+    #need_ok "git failed"
+    #"${CFG_GIT}" submodule foreach --recursive git checkout .
+    #need_ok "git failed"
 
     cd ${CFG_BUILD_DIR}
 fi
 
 # Configure llvm, only if necessary
 step_msg "looking at LLVM"
 CFG_LLVM_SRC_DIR=${CFG_SRC_DIR}src/llvm/
 for t in $CFG_HOST
diff --git a/mk/cfg/x86_64-unknown-bitrig.mk b/mk/cfg/x86_64-unknown-bitrig.mk
new file mode 100644
index 0000000..75a5a9d
--- /dev/null
+++ b/mk/cfg/x86_64-unknown-bitrig.mk
@@ -0,0 +1,26 @@
+# x86_64-unknown-bitrig-elf configuration
+CC_x86_64-unknown-bitrig=$(CC)
+CXX_x86_64-unknown-bitrig=$(CXX)
+CPP_x86_64-unknown-bitrig=$(CPP)
+AR_x86_64-unknown-bitrig=$(AR)
+CFG_LIB_NAME_x86_64-unknown-bitrig=lib$(1).so
+CFG_STATIC_LIB_NAME_x86_64-unknown-bitrig=lib$(1).a
+CFG_LIB_GLOB_x86_64-unknown-bitrig=lib$(1)-*.so
+CFG_LIB_DSYM_GLOB_x86_64-unknown-bitrig=$(1)-*.dylib.dSYM
+CFG_JEMALLOC_CFLAGS_x86_64-unknown-bitrig := -I/usr/include -I/usr/local/include $(CFLAGS)
+CFG_GCCISH_CFLAGS_x86_64-unknown-bitrig := -Wall -Werror -g -fPIC -I/usr/include -I/usr/local/include $(CFLAGS)
+CFG_GCCISH_LINK_FLAGS_x86_64-unknown-bitrig := -shared -pic -g -pthread $(LDFLAGS)
+CFG_GCCISH_DEF_FLAG_x86_64-unknown-bitrig := -Wl,--export-dynamic,--dynamic-list=
+CFG_GCCISH_PRE_LIB_FLAGS_x86_64-unknown-bitrig := -Wl,-pic -Wl,-whole-archive
+CFG_GCCISH_POST_LIB_FLAGS_x86_64-unknown-bitrig := -Wl,-no-whole-archive
+CFG_DEF_SUFFIX_x86_64-unknown-bitrig := .bsd.def
+CFG_LLC_FLAGS_x86_64-unknown-bitrig :=
+CFG_INSTALL_NAME_x86_64-unknown-bitrig =
+CFG_EXE_SUFFIX_x86_64-unknown-bitrig :=
+CFG_WINDOWSY_x86_64-unknown-bitrig :=
+CFG_UNIXY_x86_64-unknown-bitrig := 1
+CFG_PATH_MUNGE_x86_64-unknown-bitrig :=
+CFG_LDPATH_x86_64-unknown-bitrig :=
+CFG_RUN_x86_64-unknown-bitrig=$(2)
+CFG_RUN_TARG_x86_64-unknown-bitrig=$(call CFG_RUN_x86_64-unknown-bitrig,,$(2))
+CFG_GNU_TRIPLE_x86_64-unknown-bitrig := x86_64-unknown-bitrig
diff --git a/mk/main.mk b/mk/main.mk
index a97e68a..c2d145e 100644
--- a/mk/main.mk
+++ b/mk/main.mk
@@ -394,17 +394,17 @@ CSREQ$(1)_T_$(2)_H_$(3) = \
 ifeq ($(1),0)
 # Don't run the stage0 compiler under valgrind - that ship has sailed
 CFG_VALGRIND_COMPILE$(1) =
 else
 CFG_VALGRIND_COMPILE$(1) = $$(CFG_VALGRIND_COMPILE)
 endif
 
 # Add RUSTFLAGS_STAGEN values to the build command
-EXTRAFLAGS_STAGE$(1) = $$(RUSTFLAGS_STAGE$(1))
+EXTRAFLAGS_STAGE$(1) = --sysroot $$(HROOT$(1)_H_$(3)) $$(RUSTFLAGS_STAGE$(1))
 
 CFGFLAG$(1)_T_$(2)_H_$(3) = stage$(1)
 
 endef
 
 # Same macro/variables as above, but defined in a separate loop so it can use
 # all the variables above for all archs. The RPATH_VAR setup sometimes needs to
 # reach across triples to get things in order.
diff --git a/mk/platform.mk b/mk/platform.mk
index 50bf51b..ecfe451 100644
--- a/mk/platform.mk
+++ b/mk/platform.mk
@@ -139,24 +139,24 @@ ifdef CFG_CCACHE_BASEDIR
   export CCACHE_BASEDIR
 endif
 
 FIND_COMPILER = $(word 1,$(1:ccache=))
 
 define CFG_MAKE_TOOLCHAIN
   # Prepend the tools with their prefix if cross compiling
   ifneq ($(CFG_BUILD),$(1))
-	CC_$(1)=$(CROSS_PREFIX_$(1))$(CC_$(1))
-	CXX_$(1)=$(CROSS_PREFIX_$(1))$(CXX_$(1))
-	CPP_$(1)=$(CROSS_PREFIX_$(1))$(CPP_$(1))
-	AR_$(1)=$(CROSS_PREFIX_$(1))$(AR_$(1))
-	RUSTC_CROSS_FLAGS_$(1)=-C linker=$$(call FIND_COMPILER,$$(CC_$(1))) \
-	    -C ar=$$(call FIND_COMPILER,$$(AR_$(1))) $(RUSTC_CROSS_FLAGS_$(1))
+  CC_$(1)=$(CROSS_PREFIX_$(1))$(CC_$(1))
+  CXX_$(1)=$(CROSS_PREFIX_$(1))$(CXX_$(1))
+  CPP_$(1)=$(CROSS_PREFIX_$(1))$(CPP_$(1))
+  AR_$(1)=$(CROSS_PREFIX_$(1))$(AR_$(1))
+  RUSTC_CROSS_FLAGS_$(1)=-C linker=$$(call FIND_COMPILER,$$(CC_$(1))) \
+      -C ar=$$(call FIND_COMPILER,$$(AR_$(1))) $(RUSTC_CROSS_FLAGS_$(1))
 
-	RUSTC_FLAGS_$(1)=$$(RUSTC_CROSS_FLAGS_$(1)) $(RUSTC_FLAGS_$(1))
+  RUSTC_FLAGS_$(1)=$$(RUSTC_CROSS_FLAGS_$(1)) $(RUSTC_FLAGS_$(1))
   endif
 
   CFG_COMPILE_C_$(1) = $$(CC_$(1)) \
         $$(CFG_GCCISH_CFLAGS) \
         $$(CFG_GCCISH_CFLAGS_$(1)) \
         $$(CFG_DEPEND_FLAGS) \
         -c -o $$(1) $$(2)
   CFG_LINK_C_$(1) = $$(CC_$(1)) \
@@ -174,29 +174,37 @@ define CFG_MAKE_TOOLCHAIN
   CFG_LINK_CXX_$(1) = $$(CXX_$(1)) \
         $$(CFG_GCCISH_LINK_FLAGS) -o $$(1) \
         $$(CFG_GCCISH_LINK_FLAGS_$(1)) \
         $$(CFG_GCCISH_DEF_FLAG_$(1))$$(3) $$(2) \
         $$(call CFG_INSTALL_NAME_$(1),$$(4))
 
   ifeq ($$(findstring $(HOST_$(1)),arm aarch64 mips mipsel),)
 
+  # On Bitrig, we need the relocation model to be PIC for everthing
+  ifeq (,$(filter $(OSTYPE_$(1)),bitrig))
+    LLVM_MC_RELOCATION_MODEL="pic"
+  else
+    LLVM_MC_RELOCATION_MODEL="default"
+  endif
+
   # We're using llvm-mc as our assembler because it supports
   # .cfi pseudo-ops on mac
   CFG_ASSEMBLE_$(1)=$$(CPP_$(1)) -E $$(CFG_DEPEND_FLAGS) $$(2) | \
                     $$(LLVM_MC_$$(CFG_BUILD)) \
                     -assemble \
+                    -relocation-model=$$(LLVM_MC_RELOCATION_MODEL) \
                     -filetype=obj \
                     -triple=$(1) \
                     -o=$$(1)
   else
 
   # For the ARM, AARCH64 and MIPS crosses, use the toolchain assembler
   # FIXME: We should be able to use the LLVM assembler
   CFG_ASSEMBLE_$(1)=$$(CC_$(1)) $$(CFG_GCCISH_CFLAGS_$(1)) \
-		    $$(CFG_DEPEND_FLAGS) $$(2) -c -o $$(1)
+        $$(CFG_DEPEND_FLAGS) $$(2) -c -o $$(1)
 
   endif
 
 endef
 
 $(foreach target,$(CFG_TARGET), \
   $(eval $(call CFG_MAKE_TOOLCHAIN,$(target))))
diff --git a/src/compiletest/util.rs b/src/compiletest/util.rs
index a116cc3..f4050f7 100644
--- a/src/compiletest/util.rs
+++ b/src/compiletest/util.rs
@@ -18,16 +18,17 @@ static OS_TABLE: &'static [(&'static str, &'static str)] = &[
     ("mingw32", "windows"),
     ("win32", "windows"),
     ("windows", "windows"),
     ("darwin", "macos"),
     ("android", "android"),
     ("linux", "linux"),
     ("freebsd", "freebsd"),
     ("dragonfly", "dragonfly"),
+    ("bitrig", "bitrig"),
 ];
 
 pub fn get_os(triple: &str) -> &'static str {
     for &(triple_os, os) in OS_TABLE.iter() {
         if triple.contains(triple_os) {
             return os
         }
     }
diff --git a/src/doc/reference.md b/src/doc/reference.md
index a907f09..7704dfd 100644
--- a/src/doc/reference.md
+++ b/src/doc/reference.md
@@ -2162,17 +2162,18 @@ The following configurations must be defined by the implementation:
 * `target_arch = "..."`. Target CPU architecture, such as `"x86"`, `"x86_64"`
   `"mips"`, `"arm"`, or `"aarch64"`.
 * `target_endian = "..."`. Endianness of the target CPU, either `"little"` or
   `"big"`.
 * `target_family = "..."`. Operating system family of the target, e. g.
   `"unix"` or `"windows"`. The value of this configuration option is defined
   as a configuration itself, like `unix` or `windows`.
 * `target_os = "..."`. Operating system of the target, examples include
-  `"win32"`, `"macos"`, `"linux"`, `"android"`, `"freebsd"` or `"dragonfly"`.
+  `"win32"`, `"macos"`, `"linux"`, `"android"`, `"freebsd"`, `"dragonfly"`, or
+  `"bitrig"`.
 * `target_word_size = "..."`. Target word size in bits. This is set to `"32"`
   for targets with 32-bit pointers, and likewise set to `"64"` for 64-bit
   pointers.
 * `unix`. See `target_family`.
 * `windows`. See `target_family`.
 
 ### Lint check attributes
 
diff --git a/src/etc/local_stage0.sh b/src/etc/local_stage0.sh
index 56ebd4f..6eac786 100755
--- a/src/etc/local_stage0.sh
+++ b/src/etc/local_stage0.sh
@@ -13,17 +13,17 @@ TARG_DIR=$1
 PREFIX=$2
 RUSTLIBDIR=$3
 
 LIB_DIR=lib
 LIB_PREFIX=lib
 
 OS=`uname -s`
 case $OS in
-    ("Linux"|"FreeBSD"|"DragonFly")
+    ("Linux"|"FreeBSD"|"DragonFly"|"Bitrig")
     BIN_SUF=
     LIB_SUF=.so
     break
     ;;
     ("Darwin")
     BIN_SUF=
     LIB_SUF=.dylib
     break
diff --git a/src/libbacktrace/configure b/src/libbacktrace/configure
index f4f9d05..1d495bb 100755
--- a/src/libbacktrace/configure
+++ b/src/libbacktrace/configure
@@ -5645,17 +5645,17 @@ else
     ;;
 
   amigaos*)
     # On AmigaOS with pdksh, this test takes hours, literally.
     # So we just punt and use a minimum line length of 8192.
     lt_cv_sys_max_cmd_len=8192;
     ;;
 
-  netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)
+  netbsd* | freebsd* | openbsd* | darwin* | dragonfly* | bitrig*)
     # This has been around since 386BSD, at least.  Likely further.
     if test -x /sbin/sysctl; then
       lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`
     elif test -x /usr/sbin/sysctl; then
       lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`
     else
       lt_cv_sys_max_cmd_len=65536	# usable default for all BSDs
     fi
diff --git a/src/libbacktrace/ltmain.sh b/src/libbacktrace/ltmain.sh
index 9503ec8..eaef55a 100644
--- a/src/libbacktrace/ltmain.sh
+++ b/src/libbacktrace/ltmain.sh
@@ -4736,17 +4736,17 @@ func_mode_link ()
 	  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-beos* | *-cegcc* | *-*-haiku*)
 	    # These systems don't actually have a C or math library (as such)
 	    continue
 	    ;;
 	  *-*-os2*)
 	    # These systems don't actually have a C library (as such)
 	    test "X$arg" = "X-lc" && continue
 	    ;;
-	  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)
+	  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly* | *-*-bitrig*)
 	    # Do not include libc due to us having libc/libc_r.
 	    test "X$arg" = "X-lc" && continue
 	    ;;
 	  *-*-rhapsody* | *-*-darwin1.[012])
 	    # Rhapsody C and math libraries are in the System framework
 	    deplibs="$deplibs System.ltframework"
 	    continue
 	    ;;
diff --git a/src/libcollections/string.rs b/src/libcollections/string.rs
index 59418f5..507703c 100644
--- a/src/libcollections/string.rs
+++ b/src/libcollections/string.rs
@@ -916,28 +916,16 @@ impl FromStr for String {
 }
 
 /// A generic trait for converting a value to a string
 pub trait ToString {
     /// Converts the value of `self` to an owned string
     fn to_string(&self) -> String;
 }
 
-#[cfg(stage0)]
-impl<T: fmt::Show> ToString for T {
-    fn to_string(&self) -> String {
-        use core::fmt::Writer;
-        let mut buf = String::new();
-        let _ = buf.write_fmt(format_args!("{}", self));
-        buf.shrink_to_fit();
-        buf
-    }
-}
-
-#[cfg(not(stage0))]
 impl<T: fmt::String> ToString for T {
     fn to_string(&self) -> String {
         use core::fmt::Writer;
         let mut buf = String::new();
         let _ = buf.write_fmt(format_args!("{}", self));
         buf.shrink_to_fit();
         buf
     }
diff --git a/src/libcollections/vec.rs b/src/libcollections/vec.rs
index 5fc3faf..312d739 100644
--- a/src/libcollections/vec.rs
+++ b/src/libcollections/vec.rs
@@ -1449,25 +1449,16 @@ impl<T> Default for Vec<T> {
 
 #[experimental = "waiting on Show stability"]
 impl<T: fmt::Show> fmt::Show for Vec<T> {
     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
         fmt::Show::fmt(self.as_slice(), f)
     }
 }
 
-#[cfg(stage0)]
-#[experimental = "waiting on Show stability"]
-impl<T: fmt::Show> fmt::String for Vec<T> {
-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
-        fmt::String::fmt(self.as_slice(), f)
-    }
-}
-
-#[cfg(not(stage0))]
 #[experimental = "waiting on Show stability"]
 impl<T: fmt::String> fmt::String for Vec<T> {
     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
         fmt::String::fmt(self.as_slice(), f)
     }
 }
 
 impl<'a> fmt::Writer for Vec<u8> {
diff --git a/src/libcore/fmt/mod.rs b/src/libcore/fmt/mod.rs
index f9027f1..867499b 100644
--- a/src/libcore/fmt/mod.rs
+++ b/src/libcore/fmt/mod.rs
@@ -858,38 +858,16 @@ impl<T: Show> Show for [T] {
         }
         if f.flags & (1 << (rt::FlagAlternate as uint)) == 0 {
             try!(write!(f, "]"));
         }
         Ok(())
     }
 }
 
-#[cfg(stage0)]
-impl<T: Show> String for [T] {
-    fn fmt(&self, f: &mut Formatter) -> Result {
-        if f.flags & (1 << (rt::FlagAlternate as uint)) == 0 {
-            try!(write!(f, "["));
-        }
-        let mut is_first = true;
-        for x in self.iter() {
-            if is_first {
-                is_first = false;
-            } else {
-                try!(write!(f, ", "));
-            }
-            try!(write!(f, "{}", *x))
-        }
-        if f.flags & (1 << (rt::FlagAlternate as uint)) == 0 {
-            try!(write!(f, "]"));
-        }
-        Ok(())
-    }
-}
-#[cfg(not(stage0))]
 impl<T: String> String for [T] {
     fn fmt(&self, f: &mut Formatter) -> Result {
         if f.flags & (1 << (rt::FlagAlternate as uint)) == 0 {
             try!(write!(f, "["));
         }
         let mut is_first = true;
         for x in self.iter() {
             if is_first {
diff --git a/src/liblibc/lib.rs b/src/liblibc/lib.rs
index e48272b..f34b6fe 100644
--- a/src/liblibc/lib.rs
+++ b/src/liblibc/lib.rs
@@ -276,30 +276,31 @@ pub use funcs::bsd43::{shutdown};
 #[cfg(windows)] pub use funcs::extra::kernel32::{DisconnectNamedPipe, OpenProcess};
 #[cfg(windows)] pub use funcs::extra::kernel32::{MoveFileExW, VirtualProtect};
 #[cfg(windows)] pub use funcs::extra::msvcrt::{get_osfhandle, open_osfhandle};
 #[cfg(windows)] pub use funcs::extra::winsock::{ioctlsocket};
 
 #[cfg(any(target_os = "linux",
           target_os = "android",
           target_os = "freebsd",
-          target_os = "dragonfly"))]
+          target_os = "dragonfly",
+          target_os = "bitrig"))]
 pub use consts::os::posix01::{CLOCK_REALTIME, CLOCK_MONOTONIC};
 
 #[cfg(any(target_os = "linux", target_os = "android"))]
 pub use funcs::posix01::unistd::{fdatasync};
 #[cfg(any(target_os = "linux", target_os = "android"))]
 pub use types::os::arch::extra::{sockaddr_ll};
 #[cfg(any(target_os = "linux", target_os = "android"))]
 pub use consts::os::extra::{AF_PACKET};
 
 #[cfg(all(unix, not(target_os = "freebsd")))]
 pub use consts::os::extra::{MAP_STACK};
 
-#[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+#[cfg(any(target_os = "freebsd", target_os = "dragonfly", target_os = "bitrig"))]
 pub use consts::os::bsd44::{TCP_KEEPIDLE};
 
 #[cfg(any(target_os = "macos", target_os = "ios"))]
 pub use consts::os::bsd44::{TCP_KEEPALIVE};
 #[cfg(any(target_os = "macos", target_os = "ios"))]
 pub use consts::os::extra::{F_FULLFSYNC};
 
 #[cfg(any(target_os = "macos", target_os = "ios"))]
@@ -1326,16 +1327,232 @@ pub mod types {
             }
             pub mod bsd44 {
             }
             pub mod extra {
             }
         }
     }
 
+    #[cfg(target_os = "bitrig")]
+    pub mod os {
+        pub mod common {
+            pub mod posix01 {
+                use types::common::c95::{c_void};
+                use types::os::arch::c95::{c_char, c_int, size_t,
+                                                 time_t, suseconds_t, c_long};
+                use types::os::arch::c99::{uintptr_t};
+
+                pub type pthread_t = uintptr_t;
+
+                #[repr(C)]
+                #[deriving(Copy)] pub struct glob_t {
+                    pub gl_pathc:  c_int,
+                    pub gl_matchc: c_int,
+                    pub gl_offs:   c_int,
+                    pub gl_flags:  c_int,
+                    pub gl_pathv:  *mut *mut c_char,
+                    pub __unused1: *mut c_void,
+                    pub __unused2: *mut c_void,
+                    pub __unused3: *mut c_void,
+                    pub __unused4: *mut c_void,
+                    pub __unused5: *mut c_void,
+                    pub __unused6: *mut c_void,
+                    pub __unused7: *mut c_void,
+                }
+
+                #[repr(C)]
+                #[deriving(Copy)] pub struct timeval {
+                    pub tv_sec: time_t,
+                    pub tv_usec: suseconds_t,
+                }
+
+                #[repr(C)]
+                #[deriving(Copy)] pub struct timespec {
+                    pub tv_sec: time_t,
+                    pub tv_nsec: c_long,
+                }
+
+                #[deriving(Copy)] pub enum timezone {}
+
+                pub type sighandler_t = size_t;
+            }
+            pub mod bsd44 {
+                use types::common::c95::{c_void};
+                use types::os::arch::c95::{c_char, c_int, c_uint};
+
+                pub type socklen_t = u32;
+                pub type sa_family_t = u8;
+                pub type in_port_t = u16;
+                pub type in_addr_t = u32;
+                #[repr(C)]
+                #[deriving(Copy)] pub struct sockaddr {
+                    pub sa_len: u8,
+                    pub sa_family: sa_family_t,
+                    pub sa_data: [u8; 14],
+                }
+                #[repr(C)]
+                #[deriving(Copy)] pub struct sockaddr_storage {
+                    pub ss_len: u8,
+                    pub ss_family: sa_family_t,
+                    pub __ss_pad1: [u8; 6],
+                    pub __ss_align: i64,
+                    pub __ss_pad2: [u8; 112],
+                }
+                #[repr(C)]
+                #[deriving(Copy)] pub struct sockaddr_in {
+                    pub sin_len: u8,
+                    pub sin_family: sa_family_t,
+                    pub sin_port: in_port_t,
+                    pub sin_addr: in_addr,
+                    pub sin_zero: [u8; 8],
+                }
+                #[repr(C)]
+                #[deriving(Copy)] pub struct in_addr {
+                    pub s_addr: in_addr_t,
+                }
+                #[repr(C)]
+                #[deriving(Copy)] pub struct sockaddr_in6 {
+                    pub sin6_len: u8,
+                    pub sin6_family: sa_family_t,
+                    pub sin6_port: in_port_t,
+                    pub sin6_flowinfo: u32,
+                    pub sin6_addr: in6_addr,
+                    pub sin6_scope_id: u32,
+                }
+                #[repr(C)]
+                #[deriving(Copy)] pub struct in6_addr {
+                    pub s6_addr: [u16; 8]
+                }
+                #[repr(C)]
+                #[deriving(Copy)] pub struct ip_mreq {
+                    pub imr_multiaddr: in_addr,
+                    pub imr_interface: in_addr,
+                }
+                #[repr(C)]
+                #[deriving(Copy)] pub struct ip6_mreq {
+                    pub ipv6mr_multiaddr: in6_addr,
+                    pub ipv6mr_interface: c_uint,
+                }
+                #[repr(C)]
+                #[deriving(Copy)] pub struct addrinfo {
+                    pub ai_flags: c_int,
+                    pub ai_family: c_int,
+                    pub ai_socktype: c_int,
+                    pub ai_protocol: c_int,
+                    pub ai_addrlen: socklen_t,
+                    pub ai_canonname: *mut c_char,
+                    pub ai_addr: *mut sockaddr,
+                    pub ai_next: *mut addrinfo,
+                }
+                #[repr(C)]
+                #[deriving(Copy)] pub struct sockaddr_un {
+                    pub sun_len: u8,
+                    pub sun_family: sa_family_t,
+                    pub sun_path: [c_char; 104]
+                }
+                #[repr(C)]
+                #[deriving(Copy)] pub struct ifaddrs {
+                    pub ifa_next: *mut ifaddrs,
+                    pub ifa_name: *mut c_char,
+                    pub ifa_flags: c_uint,
+                    pub ifa_addr: *mut sockaddr,
+                    pub ifa_netmask: *mut sockaddr,
+                    pub ifa_dstaddr: *mut sockaddr,
+                    pub ifa_data: *mut c_void
+                }
+            }
+        }
+
+        #[cfg(target_arch = "x86_64")]
+        pub mod arch {
+            pub mod c95 {
+                pub type c_char = i8;
+                pub type c_schar = i8;
+                pub type c_uchar = u8;
+                pub type c_short = i16;
+                pub type c_ushort = u16;
+                pub type c_int = i32;
+                pub type c_uint = u32;
+                pub type c_long = i64;
+                pub type c_ulong = u64;
+                pub type c_float = f32;
+                pub type c_double = f64;
+                pub type size_t = u64;
+                pub type ptrdiff_t = i64;
+                pub type clock_t = i32;
+                pub type time_t = i64;
+                pub type suseconds_t = i64;
+                pub type wchar_t = i32;
+            }
+            pub mod c99 {
+                pub type c_longlong = i64;
+                pub type c_ulonglong = u64;
+                pub type intptr_t = i64;
+                pub type uintptr_t = u64;
+                pub type intmax_t = i64;
+                pub type uintmax_t = u64;
+            }
+            pub mod posix88 {
+                use types::os::arch::c95::{c_long};
+                pub type off_t = i64;
+                pub type dev_t = i32;
+                pub type ino_t = u64;
+                pub type pid_t = i32;
+                pub type uid_t = u32;
+                pub type gid_t = u32;
+                pub type useconds_t = u32;
+                pub type mode_t = u32;
+                pub type ssize_t = c_long;
+            }
+            pub mod posix01 {
+                use types::common::c95::{c_void};
+                use types::os::arch::c95::{time_t};
+                use types::common::c99::{uint32_t, int64_t};
+                use types::os::arch::posix88::{dev_t, gid_t, ino_t, mode_t, off_t, uid_t};
+                use types::os::common::posix01::{timespec};
+
+                pub type nlink_t = uint32_t;
+
+                #[repr(C)]
+                #[deriving(Copy)] pub struct stat {
+                    pub st_mode: mode_t,
+                    pub st_dev: dev_t,
+                    pub st_ino: ino_t,
+                    pub st_nlink: nlink_t,
+                    pub st_uid: uid_t,
+                    pub st_gid: gid_t,
+                    pub st_rdev: dev_t,
+                    pub st_atim: timespec,
+                    pub st_mtim: timespec,
+                    pub st_ctim: timespec,
+                    pub st_size: off_t,
+                    pub st_blocks: int64_t,
+                    pub st_blksize: uint32_t,
+                    pub st_flags: uint32_t,
+                    pub st_gen: uint32_t,
+                    pub __st_birthtim: timespec,
+                }
+                #[repr(C)]
+                #[deriving(Copy)] pub struct utimbuf {
+                    pub actime: time_t,
+                    pub modtime: time_t,
+                }
+
+                pub type pthread_attr_t = *mut c_void;
+            }
+            pub mod posix08 {
+            }
+            pub mod bsd44 {
+            }
+            pub mod extra {
+            }
+        }
+    }
+
     #[cfg(target_os = "windows")]
     pub mod os {
         pub mod common {
             pub mod posix01 {
                 use types::os::arch::c95::{c_short, time_t, c_long};
                 use types::os::arch::extra::{int64, time64_t};
                 use types::os::arch::posix88::{dev_t, ino_t};
 
@@ -3246,17 +3463,17 @@ pub mod consts {
             pub const _SC_VERSION : c_int = 25;
             pub const _SC_RE_DUP_MAX : c_int = 26;
             pub const _SC_STREAM_MAX : c_int = 27;
             pub const _SC_TZNAME_MAX : c_int = 28;
             pub const _SC_PAGESIZE : c_int = 39;
         }
     }
 
-    #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+    #[cfg(any(target_os = "freebsd", target_os = "dragonfly", target_os = "bitrig"))]
     pub mod os {
         pub mod c95 {
             use types::os::arch::c95::{c_int, c_uint};
 
             pub const EXIT_FAILURE : c_int = 1;
             pub const EXIT_SUCCESS : c_int = 0;
             pub const RAND_MAX : c_int = 2147483647;
             pub const EOF : c_int = -1;
@@ -3516,16 +3733,19 @@ pub mod consts {
                           target_arch = "mipsel",
                           target_arch = "x86",
                           target_arch = "x86_64")))]
             pub const PTHREAD_STACK_MIN: size_t = 2048;
 
             #[cfg(target_os = "dragonfly")]
             pub const PTHREAD_STACK_MIN: size_t = 1024;
 
+            #[cfg(target_os = "bitrig")]
+            pub const PTHREAD_STACK_MIN: size_t = 2048;
+
             pub const CLOCK_REALTIME: c_int = 0;
             pub const CLOCK_MONOTONIC: c_int = 4;
         }
         pub mod posix08 {
         }
         pub mod bsd44 {
             use types::os::arch::c95::c_int;
 
@@ -3596,16 +3816,19 @@ pub mod consts {
             pub const MAP_RENAME : c_int = 0x0020;
             pub const MAP_NORESERVE : c_int = 0x0040;
             pub const MAP_HASSEMAPHORE : c_int = 0x0200;
             pub const MAP_STACK : c_int = 0x0400;
             pub const MAP_NOSYNC : c_int = 0x0800;
             pub const MAP_NOCORE : c_int = 0x020000;
 
             pub const IPPROTO_RAW : c_int = 255;
+
+            #[cfg(target_os = "bitrig")]
+            pub const PATH_MAX: c_int = 1024;
         }
         pub mod sysconf {
             use types::os::arch::c95::c_int;
 
             pub const _SC_ARG_MAX : c_int = 1;
             pub const _SC_CHILD_MAX : c_int = 2;
             pub const _SC_CLK_TCK : c_int = 3;
             pub const _SC_NGROUPS_MAX : c_int = 4;
@@ -4351,44 +4574,47 @@ pub mod funcs {
         }
     }
 
     #[cfg(any(target_os = "linux",
               target_os = "android",
               target_os = "macos",
               target_os = "ios",
               target_os = "freebsd",
-              target_os = "dragonfly"))]
+              target_os = "dragonfly",
+              target_os = "bitrig"))]
     pub mod posix88 {
         pub mod stat_ {
             use types::os::arch::c95::{c_char, c_int};
             use types::os::arch::posix01::stat;
             use types::os::arch::posix88::mode_t;
 
             extern {
                 pub fn chmod(path: *const c_char, mode: mode_t) -> c_int;
                 pub fn fchmod(fd: c_int, mode: mode_t) -> c_int;
 
                 #[cfg(any(target_os = "linux",
                           target_os = "freebsd",
                           target_os = "dragonfly",
+                          target_os = "bitrig",
                           target_os = "android",
                           target_os = "ios"))]
                 pub fn fstat(fildes: c_int, buf: *mut stat) -> c_int;
 
                 #[cfg(target_os = "macos")]
                 #[link_name = "fstat64"]
                 pub fn fstat(fildes: c_int, buf: *mut stat) -> c_int;
 
                 pub fn mkdir(path: *const c_char, mode: mode_t) -> c_int;
                 pub fn mkfifo(path: *const c_char, mode: mode_t) -> c_int;
 
                 #[cfg(any(target_os = "linux",
                           target_os = "freebsd",
                           target_os = "dragonfly",
+                          target_os = "bitrig",
                           target_os = "android",
                           target_os = "ios"))]
                 pub fn stat(path: *const c_char, buf: *mut stat) -> c_int;
 
                 #[cfg(target_os = "macos")]
                 #[link_name = "stat64"]
                 pub fn stat(path: *const c_char, buf: *mut stat) -> c_int;
             }
@@ -4571,26 +4797,28 @@ pub mod funcs {
 
     }
 
     #[cfg(any(target_os = "linux",
               target_os = "android",
               target_os = "macos",
               target_os = "ios",
               target_os = "freebsd",
-              target_os = "dragonfly"))]
+              target_os = "dragonfly",
+              target_os = "bitrig"))]
     pub mod posix01 {
         pub mod stat_ {
             use types::os::arch::c95::{c_char, c_int};
             use types::os::arch::posix01::stat;
 
             extern {
                 #[cfg(any(target_os = "linux",
                           target_os = "freebsd",
                           target_os = "dragonfly",
+                          target_os = "bitrig",
                           target_os = "android",
                           target_os = "ios"))]
                 pub fn lstat(path: *const c_char, buf: *mut stat) -> c_int;
 
                 #[cfg(target_os = "macos")]
                 #[link_name = "lstat64"]
                 pub fn lstat(path: *const c_char, buf: *mut stat) -> c_int;
             }
@@ -4688,17 +4916,18 @@ pub mod funcs {
 
 
     #[cfg(any(target_os = "windows",
               target_os = "linux",
               target_os = "android",
               target_os = "macos",
               target_os = "ios",
               target_os = "freebsd",
-              target_os = "dragonfly"))]
+              target_os = "dragonfly",
+              target_os = "bitrig"))]
     pub mod posix08 {
         pub mod unistd {
         }
     }
 
     #[cfg(not(windows))]
     pub mod bsd43 {
         use types::common::c95::{c_void};
@@ -4774,17 +5003,18 @@ pub mod funcs {
                           addrlen: c_int) -> c_int;
             pub fn shutdown(socket: SOCKET, how: c_int) -> c_int;
         }
     }
 
     #[cfg(any(target_os = "macos",
               target_os = "ios",
               target_os = "freebsd",
-              target_os = "dragonfly"))]
+              target_os = "dragonfly",
+              target_os = "bitrig"))]
     pub mod bsd44 {
         use types::common::c95::{c_void};
         use types::os::arch::c95::{c_char, c_uchar, c_int, c_uint, c_ulong, size_t};
 
         extern {
             pub fn ioctl(d: c_int, request: c_ulong, ...) -> c_int;
             pub fn sysctl(name: *mut c_int,
                           namelen: c_uint,
@@ -4803,20 +5033,21 @@ pub mod funcs {
                                    mibp: *mut c_int,
                                    sizep: *mut size_t)
                                    -> c_int;
             pub fn getdtablesize() -> c_int;
             pub fn madvise(addr: *mut c_void, len: size_t, advice: c_int)
                            -> c_int;
             pub fn mincore(addr: *mut c_void, len: size_t, vec: *mut c_uchar)
                            -> c_int;
+            pub fn realpath(pathname: *const c_char, resolved: *mut c_char)
+                            -> *mut c_char;
         }
     }
 
-
     #[cfg(any(target_os = "linux", target_os = "android"))]
     pub mod bsd44 {
         use types::common::c95::{c_void};
         use types::os::arch::c95::{c_uchar, c_int, size_t};
 
         extern {
             pub fn getdtablesize() -> c_int;
             pub fn ioctl(d: c_int, request: c_int, ...) -> c_int;
@@ -4837,17 +5068,17 @@ pub mod funcs {
         use types::os::arch::c95::{c_char, c_int};
 
         extern {
             pub fn _NSGetExecutablePath(buf: *mut c_char, bufsize: *mut u32)
                                         -> c_int;
         }
     }
 
-    #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+    #[cfg(any(target_os = "freebsd", target_os = "dragonfly", target_os = "bitrig"))]
     pub mod extra {
     }
 
     #[cfg(any(target_os = "linux", target_os = "android"))]
     pub mod extra {
     }
 
 
diff --git a/src/librustc_back/arm.rs b/src/librustc_back/arm.rs
index 7e28cd6..f97a188 100644
--- a/src/librustc_back/arm.rs
+++ b/src/librustc_back/arm.rs
@@ -56,17 +56,17 @@ pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs
           abi::OsAndroid => {
             "e-p:32:32:32\
                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\
                 -f32:32:32-f64:64:64\
                 -v64:64:64-v128:64:128\
                 -a:0:64-n32".to_string()
           }
 
-          abi::OsFreebsd | abi::OsDragonfly => {
+          abi::OsFreebsd | abi::OsDragonfly | abi::OsBitrig => {
             "e-p:32:32:32\
                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\
                 -f32:32:32-f64:64:64\
                 -v64:64:64-v128:64:128\
                 -a:0:64-n32".to_string()
           }
         },
 
diff --git a/src/librustc_back/mips.rs b/src/librustc_back/mips.rs
index bc77321..bb67b9f 100644
--- a/src/librustc_back/mips.rs
+++ b/src/librustc_back/mips.rs
@@ -51,17 +51,17 @@ pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs
           abi::OsAndroid => {
             "E-p:32:32:32\
                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\
                 -f32:32:32-f64:64:64\
                 -v64:64:64-v128:64:128\
                 -a:0:64-n32".to_string()
           }
 
-          abi::OsFreebsd | abi::OsDragonfly => {
+          abi::OsFreebsd | abi::OsDragonfly | abi::OsBitrig => {
             "E-p:32:32:32\
                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\
                 -f32:32:32-f64:64:64\
                 -v64:64:64-v128:64:128\
                 -a:0:64-n32".to_string()
           }
         },
 
diff --git a/src/librustc_back/mipsel.rs b/src/librustc_back/mipsel.rs
index 3eea0a0..dc1e770 100644
--- a/src/librustc_back/mipsel.rs
+++ b/src/librustc_back/mipsel.rs
@@ -51,17 +51,17 @@ pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs
           abi::OsAndroid => {
             "e-p:32:32:32\
                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\
                 -f32:32:32-f64:64:64\
                 -v64:64:64-v128:64:128\
                 -a:0:64-n32".to_string()
           }
 
-          abi::OsFreebsd | abi::OsDragonfly => {
+          abi::OsFreebsd | abi::OsDragonfly | abi::OsBitrig => {
             "e-p:32:32:32\
                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\
                 -f32:32:32-f64:64:64\
                 -v64:64:64-v128:64:128\
                 -a:0:64-n32".to_string()
           }
         },
 
diff --git a/src/librustc_back/rpath.rs b/src/librustc_back/rpath.rs
index db1dfa6..ece4bef 100644
--- a/src/librustc_back/rpath.rs
+++ b/src/librustc_back/rpath.rs
@@ -210,17 +210,17 @@ mod test {
             is_like_osx: false,
             realpath: |p| Ok(p.clone())
         };
         let res = get_rpath_relative_to_output(config, &Path::new("lib/libstd.so"));
         assert_eq!(res, "$ORIGIN/../lib");
     }
 
     #[test]
-    #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+    #[cfg(any(target_os = "freebsd", target_os = "dragonfly", target_os = "bitrig"))]
     fn test_rpath_relative() {
         let config = &mut RPathConfig {
             used_crates: Vec::new(),
             has_rpath: true,
             is_like_osx: false,
             out_filename: Path::new("bin/rustc"),
             get_install_prefix_lib_path: || panic!(),
             realpath: |p| Ok(p.clone())
diff --git a/src/librustc_back/target/bitrig_base.rs b/src/librustc_back/target/bitrig_base.rs
new file mode 100644
index 0000000..c816904
--- /dev/null
+++ b/src/librustc_back/target/bitrig_base.rs
@@ -0,0 +1,29 @@
+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT
+// file at the top-level directory of this distribution and at
+// http://rust-lang.org/COPYRIGHT.
+//
+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
+// option. This file may not be copied, modified, or distributed
+// except according to those terms.
+
+use target::TargetOptions;
+use std::default::Default;
+
+pub fn opts() -> TargetOptions {
+    TargetOptions {
+        linker: "cc".to_string(),
+        dynamic_linking: true,
+        executables: true,
+        morestack: true,
+        linker_is_gnu: true,
+        has_rpath: true,
+        position_independent_executables: true,
+        pre_link_args: vec!(
+            "-L/usr/local/lib".to_string(),
+        ),
+
+        .. Default::default()
+    }
+}
diff --git a/src/librustc_back/target/mod.rs b/src/librustc_back/target/mod.rs
index 23c8fc7..286b024 100644
--- a/src/librustc_back/target/mod.rs
+++ b/src/librustc_back/target/mod.rs
@@ -50,16 +50,17 @@ use syntax::{diagnostic, abi};
 use std::default::Default;
 use std::io::fs::PathExtensions;
 
 mod windows_base;
 mod linux_base;
 mod apple_base;
 mod freebsd_base;
 mod dragonfly_base;
+mod bitrig_base;
 
 mod arm_apple_ios;
 mod arm_linux_androideabi;
 mod arm_unknown_linux_gnueabi;
 mod arm_unknown_linux_gnueabihf;
 mod aarch64_unknown_linux_gnu;
 mod i686_apple_darwin;
 mod i386_apple_ios;
@@ -67,16 +68,17 @@ mod i686_pc_windows_gnu;
 mod i686_unknown_dragonfly;
 mod i686_unknown_linux_gnu;
 mod mips_unknown_linux_gnu;
 mod mipsel_unknown_linux_gnu;
 mod x86_64_apple_darwin;
 mod x86_64_pc_windows_gnu;
 mod x86_64_unknown_freebsd;
 mod x86_64_unknown_dragonfly;
+mod x86_64_unknown_bitrig;
 mod x86_64_unknown_linux_gnu;
 
 /// Everything `rustc` knows about how to compile for a specific target.
 ///
 /// Every field here must be specified, and has no default value.
 #[derive(Clone, Show)]
 pub struct Target {
     /// [Data layout](http://llvm.org/docs/LangRef.html#data-layout) to pass to LLVM.
@@ -340,16 +342,18 @@ impl Target {
             arm_unknown_linux_gnueabihf,
             aarch64_unknown_linux_gnu,
 
             x86_64_unknown_freebsd,
 
             i686_unknown_dragonfly,
             x86_64_unknown_dragonfly,
 
+            x86_64_unknown_bitrig,
+
             x86_64_apple_darwin,
             i686_apple_darwin,
             i386_apple_ios,
             arm_apple_ios,
 
             x86_64_pc_windows_gnu,
             i686_pc_windows_gnu
         );
diff --git a/src/librustc_back/target/x86_64_unknown_bitrig.rs b/src/librustc_back/target/x86_64_unknown_bitrig.rs
new file mode 100644
index 0000000..bc4f8b6
--- /dev/null
+++ b/src/librustc_back/target/x86_64_unknown_bitrig.rs
@@ -0,0 +1,28 @@
+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT
+// file at the top-level directory of this distribution and at
+// http://rust-lang.org/COPYRIGHT.
+//
+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
+// option. This file may not be copied, modified, or distributed
+// except according to those terms.
+
+use target::Target;
+
+pub fn target() -> Target {
+    let mut base = super::bitrig_base::opts();
+    base.pre_link_args.push("-m64".to_string());
+
+    Target {
+        data_layout: "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\
+                     f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\
+                     s0:64:64-f80:128:128-n8:16:32:64-S128".to_string(),
+        llvm_target: "x86_64-unknown-bitrig".to_string(),
+        target_endian: "little".to_string(),
+        target_word_size: "64".to_string(),
+        arch: "x86_64".to_string(),
+        target_os: "bitrig".to_string(),
+        options: base,
+    }
+}
diff --git a/src/librustc_back/x86.rs b/src/librustc_back/x86.rs
index 52c0716..770a8e1 100644
--- a/src/librustc_back/x86.rs
+++ b/src/librustc_back/x86.rs
@@ -40,20 +40,17 @@ pub fn get_target_strs(target_triple: String, target_os: abi::Os)
 
           abi::OsLinux => {
             "e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32".to_string()
           }
           abi::OsAndroid => {
             "e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32".to_string()
           }
 
-          abi::OsFreebsd => {
-            "e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32".to_string()
-          }
-          abi::OsDragonfly => {
+          abi::OsFreebsd | abi::OsDragonfly | abi::OsBitrig => {
             "e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32".to_string()
           }
 
         },
 
         target_triple: target_triple,
 
         cc_args: vec!("-m32".to_string()),
diff --git a/src/librustc_back/x86_64.rs b/src/librustc_back/x86_64.rs
index cbb288a..dffbb96 100644
--- a/src/librustc_back/x86_64.rs
+++ b/src/librustc_back/x86_64.rs
@@ -42,22 +42,17 @@ pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs
                 s0:64:64-f80:128:128-n8:16:32:64-S128".to_string()
           }
           abi::OsAndroid => {
             "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\
                 f32:32:32-f64:64:64-v64:64:64-v128:128:128-a:0:64-\
                 s0:64:64-f80:128:128-n8:16:32:64-S128".to_string()
           }
 
-          abi::OsFreebsd => {
-            "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\
-                f32:32:32-f64:64:64-v64:64:64-v128:128:128-a:0:64-\
-                s0:64:64-f80:128:128-n8:16:32:64-S128".to_string()
-          }
-          abi::OsDragonfly => {
+          abi::OsFreebsd | abi::OsDragonfly | abi::OsBitrig => {
             "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\
                 f32:32:32-f64:64:64-v64:64:64-v128:128:128-a:0:64-\
                 s0:64:64-f80:128:128-n8:16:32:64-S128".to_string()
           }
 
         },
 
         target_triple: target_triple,
diff --git a/src/librustdoc/flock.rs b/src/librustdoc/flock.rs
index dcc9011..e07145a 100644
--- a/src/librustdoc/flock.rs
+++ b/src/librustdoc/flock.rs
@@ -58,17 +58,17 @@ mod imp {
         }
 
         pub const F_UNLCK: libc::c_short = 2;
         pub const F_WRLCK: libc::c_short = 3;
         pub const F_SETLK: libc::c_int = 12;
         pub const F_SETLKW: libc::c_int = 13;
     }
 
-    #[cfg(target_os = "dragonfly")]
+    #[cfg(any(target_os = "dragonfly", target_os = "bitrig"))]
     mod os {
         use libc;
 
         pub struct flock {
             pub l_start: libc::off_t,
             pub l_len: libc::off_t,
             pub l_pid: libc::pid_t,
             pub l_type: libc::c_short,
diff --git a/src/libstd/dynamic_lib.rs b/src/libstd/dynamic_lib.rs
index 2d013a8..bfd69c5 100644
--- a/src/libstd/dynamic_lib.rs
+++ b/src/libstd/dynamic_lib.rs
@@ -175,34 +175,36 @@ mod test {
                    expected_result, result)
         }
     }
 
     #[test]
     #[cfg(any(target_os = "linux",
               target_os = "macos",
               target_os = "freebsd",
-              target_os = "dragonfly"))]
+              target_os = "dragonfly",
+              target_os = "bitrig"))]
     fn test_errors_do_not_crash() {
         // Open /dev/null as a library to get an error, and make sure
         // that only causes an error, and not a crash.
         let path = Path::new("/dev/null");
         match DynamicLibrary::open(Some(&path)) {
             Err(_) => {}
             Ok(_) => panic!("Successfully opened the empty library.")
         }
     }
 }
 
 #[cfg(any(target_os = "linux",
           target_os = "android",
           target_os = "macos",
           target_os = "ios",
           target_os = "freebsd",
-          target_os = "dragonfly"))]
+          target_os = "dragonfly",
+          target_os = "bitrig"))]
 pub mod dl {
     pub use self::Rtld::*;
     use prelude::v1::*;
 
     use ffi::{self, CString};
     use str;
     use libc;
     use ptr;
diff --git a/src/libstd/os.rs b/src/libstd/os.rs
index cef85c2..de226b5 100644
--- a/src/libstd/os.rs
+++ b/src/libstd/os.rs
@@ -686,17 +686,18 @@ fn real_args_as_bytes() -> Vec<Vec<u8>> {
     }
 
     res
 }
 
 #[cfg(any(target_os = "linux",
           target_os = "android",
           target_os = "freebsd",
-          target_os = "dragonfly"))]
+          target_os = "dragonfly",
+          target_os = "bitrig"))]
 fn real_args_as_bytes() -> Vec<Vec<u8>> {
     use rt;
     rt::args::clone().unwrap_or_else(|| vec![])
 }
 
 #[cfg(not(windows))]
 fn real_args() -> Vec<String> {
     real_args_as_bytes().into_iter()
@@ -1325,16 +1326,47 @@ pub mod consts {
     /// platform: in this case, the empty string.
     pub const EXE_SUFFIX: &'static str = "";
 
     /// Specifies the file extension, if any, used for executable binaries
     /// on this platform: in this case, the empty string.
     pub const EXE_EXTENSION: &'static str = "";
 }
 
+#[cfg(target_os = "bitrig")]
+pub mod consts {
+    pub use os::arch_consts::ARCH;
+
+    pub const FAMILY: &'static str = "unix";
+
+    /// A string describing the specific operating system in use: in this
+    /// case, `bitrig`.
+    pub const SYSNAME: &'static str = "bitrig";
+
+    /// Specifies the filename prefix used for shared libraries on this
+    /// platform: in this case, `lib`.
+    pub const DLL_PREFIX: &'static str = "lib";
+
+    /// Specifies the filename suffix used for shared libraries on this
+    /// platform: in this case, `.so`.
+    pub const DLL_SUFFIX: &'static str = ".so";
+
+    /// Specifies the file extension used for shared libraries on this
+    /// platform that goes after the dot: in this case, `so`.
+    pub const DLL_EXTENSION: &'static str = "so";
+
+    /// Specifies the filename suffix used for executable binaries on this
+    /// platform: in this case, the empty string.
+    pub const EXE_SUFFIX: &'static str = "";
+
+    /// Specifies the file extension, if any, used for executable binaries
+    /// on this platform: in this case, the empty string.
+    pub const EXE_EXTENSION: &'static str = "";
+}
+
 #[cfg(target_os = "android")]
 pub mod consts {
     pub use os::arch_consts::ARCH;
 
     pub const FAMILY: &'static str = "unix";
 
     /// A string describing the specific operating system in use: in this
     /// case, `android`.
diff --git a/src/libstd/rt/args.rs b/src/libstd/rt/args.rs
index 86abacb..4d00af8 100644
--- a/src/libstd/rt/args.rs
+++ b/src/libstd/rt/args.rs
@@ -37,17 +37,18 @@ pub fn take() -> Option<Vec<Vec<u8>>> { imp::take() }
 pub fn put(args: Vec<Vec<u8>>) { imp::put(args) }
 
 /// Make a clone of the global arguments.
 pub fn clone() -> Option<Vec<Vec<u8>>> { imp::clone() }
 
 #[cfg(any(target_os = "linux",
           target_os = "android",
           target_os = "freebsd",
-          target_os = "dragonfly"))]
+          target_os = "dragonfly",
+          target_os = "bitrig"))]
 mod imp {
     use prelude::v1::*;
 
     use libc;
     use mem;
     use ffi;
 
     use sync::{StaticMutex, MUTEX_INIT};
diff --git a/src/libstd/rt/libunwind.rs b/src/libstd/rt/libunwind.rs
index 7cc39d7..946e25f 100644
--- a/src/libstd/rt/libunwind.rs
+++ b/src/libstd/rt/libunwind.rs
@@ -101,16 +101,20 @@ extern {}
 #[cfg(target_os = "android")]
 #[link(name = "gcc")]
 extern {}
 
 #[cfg(target_os = "dragonfly")]
 #[link(name = "gcc_pic")]
 extern {}
 
+#[cfg(target_os = "bitrig")]
+#[link(name = "c++abi")]
+extern {}
+
 extern "C" {
     // iOS on armv7 uses SjLj exceptions and requires to link
     // against corresponding routine (..._SjLj_...)
     #[cfg(not(all(target_os = "ios", target_arch = "arm")))]
     pub fn _Unwind_RaiseException(exception: *mut _Unwind_Exception)
                                   -> _Unwind_Reason_Code;
 
     #[cfg(all(target_os = "ios", target_arch = "arm"))]
diff --git a/src/libstd/rtdeps.rs b/src/libstd/rtdeps.rs
index 862808a..6814806 100644
--- a/src/libstd/rtdeps.rs
+++ b/src/libstd/rtdeps.rs
@@ -34,17 +34,17 @@ extern {}
 #[link(name = "log")]
 extern {}
 
 #[cfg(target_os = "freebsd")]
 #[link(name = "execinfo")]
 #[link(name = "pthread")]
 extern {}
 
-#[cfg(target_os = "dragonfly")]
+#[cfg(any(target_os = "dragonfly", target_os = "bitrig"))]
 #[link(name = "pthread")]
 extern {}
 
 #[cfg(target_os = "macos")]
 #[link(name = "System")]
 extern {}
 
 #[cfg(target_os = "ios")]
diff --git a/src/libstd/sys/common/net.rs b/src/libstd/sys/common/net.rs
index 902942d..1d7e45f 100644
--- a/src/libstd/sys/common/net.rs
+++ b/src/libstd/sys/common/net.rs
@@ -684,25 +684,28 @@ impl TcpStream {
         }
     }
 
     #[cfg(any(target_os = "macos", target_os = "ios"))]
     fn set_tcp_keepalive(&mut self, seconds: uint) -> IoResult<()> {
         setsockopt(self.fd(), libc::IPPROTO_TCP, libc::TCP_KEEPALIVE,
                    seconds as libc::c_int)
     }
-    #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+    #[cfg(any(target_os = "freebsd", 
+              target_os = "dragonfly",
+              target_os = "bitrig"))]
     fn set_tcp_keepalive(&mut self, seconds: uint) -> IoResult<()> {
         setsockopt(self.fd(), libc::IPPROTO_TCP, libc::TCP_KEEPIDLE,
                    seconds as libc::c_int)
     }
     #[cfg(not(any(target_os = "macos",
                   target_os = "ios",
                   target_os = "freebsd",
-                  target_os = "dragonfly")))]
+                  target_os = "dragonfly",
+                  target_os = "bitrig")))]
     fn set_tcp_keepalive(&mut self, _seconds: uint) -> IoResult<()> {
         Ok(())
     }
 
     #[cfg(target_os = "linux")]
     fn lock_nonblocking(&self) {}
 
     #[cfg(not(target_os = "linux"))]
diff --git a/src/libstd/sys/common/stack.rs b/src/libstd/sys/common/stack.rs
index ce5ab67..33a42ab 100644
--- a/src/libstd/sys/common/stack.rs
+++ b/src/libstd/sys/common/stack.rs
@@ -184,17 +184,19 @@ pub unsafe fn record_sp_limit(limit: uint) {
     }
     #[cfg(all(target_arch = "x86_64", target_os = "windows"))] #[inline(always)]
     unsafe fn target_record_sp_limit(_: uint) {
     }
     #[cfg(all(target_arch = "x86_64", target_os = "freebsd"))] #[inline(always)]
     unsafe fn target_record_sp_limit(limit: uint) {
         asm!("movq $0, %fs:24" :: "r"(limit) :: "volatile")
     }
-    #[cfg(all(target_arch = "x86_64", target_os = "dragonfly"))] #[inline(always)]
+    #[cfg(all(target_arch = "x86_64",
+              any(target_os = "dragonfly", target_os = "bitrig")))]
+    #[inline(always)]
     unsafe fn target_record_sp_limit(limit: uint) {
         asm!("movq $0, %fs:32" :: "r"(limit) :: "volatile")
     }
 
     // x86
     #[cfg(all(target_arch = "x86",
               any(target_os = "macos", target_os = "ios")))]
     #[inline(always)]
@@ -270,17 +272,19 @@ pub unsafe fn get_sp_limit() -> uint {
         return 1024;
     }
     #[cfg(all(target_arch = "x86_64", target_os = "freebsd"))] #[inline(always)]
     unsafe fn target_get_sp_limit() -> uint {
         let limit;
         asm!("movq %fs:24, $0" : "=r"(limit) ::: "volatile");
         return limit;
     }
-    #[cfg(all(target_arch = "x86_64", target_os = "dragonfly"))] #[inline(always)]
+    #[cfg(all(target_arch = "x86_64",
+              any(target_os = "dragonfly", target_os = "bitrig")))]
+    #[inline(always)]
     unsafe fn target_get_sp_limit() -> uint {
         let limit;
         asm!("movq %fs:32, $0" : "=r"(limit) ::: "volatile");
         return limit;
     }
 
 
     // x86
diff --git a/src/libstd/sys/unix/c.rs b/src/libstd/sys/unix/c.rs
index cc66187..9f38068 100644
--- a/src/libstd/sys/unix/c.rs
+++ b/src/libstd/sys/unix/c.rs
@@ -18,49 +18,52 @@ pub use self::signal::{sigaction, siginfo, sigset_t};
 pub use self::signal::{SA_ONSTACK, SA_RESTART, SA_RESETHAND, SA_NOCLDSTOP};
 pub use self::signal::{SA_NODEFER, SA_NOCLDWAIT, SA_SIGINFO, SIGCHLD};
 
 use libc;
 
 #[cfg(any(target_os = "macos",
           target_os = "ios",
           target_os = "freebsd",
-          target_os = "dragonfly"))]
+          target_os = "dragonfly",
+          target_os = "bitrig"))]
 pub const FIONBIO: libc::c_ulong = 0x8004667e;
 #[cfg(any(all(target_os = "linux",
               any(target_arch = "x86",
                   target_arch = "x86_64",
                   target_arch = "arm",
                   target_arch = "aarch64")),
           target_os = "android"))]
 pub const FIONBIO: libc::c_ulong = 0x5421;
 #[cfg(all(target_os = "linux",
           any(target_arch = "mips", target_arch = "mipsel")))]
 pub const FIONBIO: libc::c_ulong = 0x667e;
 
 #[cfg(any(target_os = "macos",
           target_os = "ios",
           target_os = "freebsd",
-          target_os = "dragonfly"))]
+          target_os = "dragonfly",
+          target_os = "bitrig"))]
 pub const FIOCLEX: libc::c_ulong = 0x20006601;
 #[cfg(any(all(target_os = "linux",
               any(target_arch = "x86",
                   target_arch = "x86_64",
                   target_arch = "arm",
                   target_arch = "aarch64")),
           target_os = "android"))]
 pub const FIOCLEX: libc::c_ulong = 0x5451;
 #[cfg(all(target_os = "linux",
           any(target_arch = "mips", target_arch = "mipsel")))]
 pub const FIOCLEX: libc::c_ulong = 0x6601;
 
 #[cfg(any(target_os = "macos",
           target_os = "ios",
           target_os = "freebsd",
-          target_os = "dragonfly"))]
+          target_os = "dragonfly",
+          target_os = "bitrig"))]
 pub const MSG_DONTWAIT: libc::c_int = 0x80;
 #[cfg(any(target_os = "linux", target_os = "android"))]
 pub const MSG_DONTWAIT: libc::c_int = 0x40;
 
 pub const WNOHANG: libc::c_int = 1;
 
 extern {
     pub fn gettimeofday(timeval: *mut libc::timeval,
@@ -102,16 +105,17 @@ mod select {
     pub fn fd_set(set: &mut fd_set, fd: i32) {
         set.fds_bits[(fd / 32) as uint] |= 1 << ((fd % 32) as uint);
     }
 }
 
 #[cfg(any(target_os = "android",
           target_os = "freebsd",
           target_os = "dragonfly",
+          target_os = "bitrig",
           target_os = "linux"))]
 mod select {
     use uint;
     use libc;
 
     pub const FD_SETSIZE: uint = 1024;
 
     #[repr(C)]
@@ -264,8 +268,46 @@ mod signal {
 
     #[repr(C)]
     pub struct sigaction {
         pub sa_handler: extern fn(libc::c_int),
         pub sa_flags: libc::c_int,
         pub sa_mask: sigset_t,
     }
 }
+
+#[cfg(target_os = "bitrig")]
+mod signal {
+    use libc;
+
+    pub const SA_ONSTACK: libc::c_int = 0x0001;
+    pub const SA_RESTART: libc::c_int = 0x0002;
+    pub const SA_RESETHAND: libc::c_int = 0x0004;
+    pub const SA_NOCLDSTOP: libc::c_int = 0x0008;
+    pub const SA_NODEFER: libc::c_int = 0x0010;
+    pub const SA_NOCLDWAIT: libc::c_int = 0x0020;
+    pub const SA_SIGINFO: libc::c_int = 0x0040;
+    pub const SIGCHLD: libc::c_int = 20;
+
+    pub type sigset_t = libc::c_uint;
+
+    // This structure has more fields, but we're not all that interested in
+    // them.
+    #[repr(C)]
+    pub struct siginfo {
+        pub si_signo: libc::c_int,
+        pub si_code: libc::c_int,
+        pub si_errno: libc::c_int,
+        // FIXME: Bitrig has a crazy union here in the siginfo, I think this
+        // layout will still work tho.  The status might be off by the size of
+        // a clock_t by my reading, but we can fix this later.
+        pub pid: libc::pid_t,
+        pub uid: libc::uid_t,
+        pub status: libc::c_int,
+    }
+
+    #[repr(C)]
+    pub struct sigaction {
+        pub sa_handler: extern fn(libc::c_int),
+        pub sa_mask: sigset_t,
+        pub sa_flags: libc::c_int,
+    }
+}
diff --git a/src/libstd/sys/unix/fs.rs b/src/libstd/sys/unix/fs.rs
index c53f9d2..f42d064 100644
--- a/src/libstd/sys/unix/fs.rs
+++ b/src/libstd/sys/unix/fs.rs
@@ -285,16 +285,43 @@ pub fn link(src: &Path, dst: &Path) -> IoResult<()> {
     let dst = cstr(dst);
     mkerr_libc(unsafe { libc::link(src.as_ptr(), dst.as_ptr()) })
 }
 
 fn mkstat(stat: &libc::stat) -> FileStat {
     // FileStat times are in milliseconds
     fn mktime(secs: u64, nsecs: u64) -> u64 { secs * 1000 + nsecs / 1000000 }
 
+    #[cfg(target_os = "bitrig")]
+    fn ctime(stat: &libc::stat) -> u64 { 
+      mktime(stat.st_ctim.tv_sec as u64, stat.st_ctim.tv_nsec as u64)
+    }
+    #[cfg(not(target_os = "bitrig"))]
+    fn ctime(stat: &libc::stat) -> u64 { 
+      mktime(stat.st_ctime as u64, stat.st_ctime_nsec as u64) 
+    }
+
+    #[cfg(target_os = "bitrig")]
+    fn atime(stat: &libc::stat) -> u64 { 
+      mktime(stat.st_atim.tv_sec as u64, stat.st_atim.tv_nsec as u64)
+    }
+    #[cfg(not(target_os = "bitrig"))]
+    fn atime(stat: &libc::stat) -> u64 { 
+      mktime(stat.st_atime as u64, stat.st_atime_nsec as u64)
+    }
+
+    #[cfg(target_os = "bitrig")]
+    fn mtime(stat: &libc::stat) -> u64 { 
+      mktime(stat.st_mtim.tv_sec as u64, stat.st_mtim.tv_nsec as u64)
+    }
+    #[cfg(not(target_os = "bitrig"))]
+    fn mtime(stat: &libc::stat) -> u64 { 
+      mktime(stat.st_mtime as u64, stat.st_mtime_nsec as u64)
+    }
+
     #[cfg(not(any(target_os = "linux", target_os = "android")))]
     fn flags(stat: &libc::stat) -> u64 { stat.st_flags as u64 }
     #[cfg(any(target_os = "linux", target_os = "android"))]
     fn flags(_stat: &libc::stat) -> u64 { 0 }
 
     #[cfg(not(any(target_os = "linux", target_os = "android")))]
     fn gen(stat: &libc::stat) -> u64 { stat.st_gen as u64 }
     #[cfg(any(target_os = "linux", target_os = "android"))]
@@ -306,19 +333,19 @@ fn mkstat(stat: &libc::stat) -> FileStat {
             libc::S_IFREG => io::FileType::RegularFile,
             libc::S_IFDIR => io::FileType::Directory,
             libc::S_IFIFO => io::FileType::NamedPipe,
             libc::S_IFBLK => io::FileType::BlockSpecial,
             libc::S_IFLNK => io::FileType::Symlink,
             _ => io::FileType::Unknown,
         },
         perm: FilePermission::from_bits_truncate(stat.st_mode as u32),
-        created: mktime(stat.st_ctime as u64, stat.st_ctime_nsec as u64),
-        modified: mktime(stat.st_mtime as u64, stat.st_mtime_nsec as u64),
-        accessed: mktime(stat.st_atime as u64, stat.st_atime_nsec as u64),
+        created: ctime(stat),
+        modified: mtime(stat),
+        accessed: atime(stat),
         unstable: UnstableFileStat {
             device: stat.st_dev as u64,
             inode: stat.st_ino as u64,
             rdev: stat.st_rdev as u64,
             nlink: stat.st_nlink as u64,
             uid: stat.st_uid as u64,
             gid: stat.st_gid as u64,
             blksize: stat.st_blksize as u64,
diff --git a/src/libstd/sys/unix/os.rs b/src/libstd/sys/unix/os.rs
index 175c4e2..976b27e 100644
--- a/src/libstd/sys/unix/os.rs
+++ b/src/libstd/sys/unix/os.rs
@@ -35,16 +35,26 @@ pub fn errno() -> int {
         extern {
             fn __error() -> *const c_int;
         }
         unsafe {
             __error()
         }
     }
 
+    #[cfg(target_os = "bitrig")]
+    fn errno_location() -> *const c_int {
+        extern {
+            fn __errno() -> *const c_int;
+        }
+        unsafe {
+            __errno()
+        }
+    }
+
     #[cfg(target_os = "dragonfly")]
     fn errno_location() -> *const c_int {
         extern {
             fn __dfly_error() -> *const c_int;
         }
         unsafe {
             __dfly_error()
         }
@@ -66,17 +76,18 @@ pub fn errno() -> int {
 }
 
 /// Get a detailed string description for the given error number
 pub fn error_string(errno: i32) -> String {
     #[cfg(any(target_os = "macos",
               target_os = "ios",
               target_os = "android",
               target_os = "freebsd",
-              target_os = "dragonfly"))]
+              target_os = "dragonfly",
+              target_os = "bitrig"))]
     fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: libc::size_t)
                   -> c_int {
         extern {
             fn strerror_r(errnum: c_int, buf: *mut c_char,
                           buflen: libc::size_t) -> c_int;
         }
         unsafe {
             strerror_r(errnum, buf, buflen)
@@ -199,16 +210,38 @@ pub fn load_self() -> Option<Vec<u8>> {
     use std::io;
 
     match io::fs::readlink(&Path::new("/proc/curproc/file")) {
         Ok(path) => Some(path.into_vec()),
         Err(..) => None
     }
 }
 
+#[cfg(target_os = "bitrig")]
+pub fn load_self() -> Option<Vec<u8>> {
+    unsafe {
+        use libc::funcs::bsd44::*;
+        use libc::consts::os::extra::*;
+        use iter::{range, repeat};
+        use rt;
+        let mut v: Vec<u8> = repeat(0i as u8).take(PATH_MAX as uint).collect();
+        let args: Vec<Vec<u8>> = rt::args::clone().unwrap_or_else(|| vec![]);
+        let ref exe: Vec<u8> = args[0];
+        let err: int = realpath(exe.as_ptr() as *const c_char,
+                                v.as_mut_ptr() as *mut c_char) as int;
+        if err == 0 { return None; }
+        let mut len = 0i;
+        for x in range(0i, PATH_MAX as int) {
+            if v[x as uint] != 0 { len += 1; }
+        }
+        v.set_len(len as uint);
+        Some(v)
+    }
+}
+
 #[cfg(any(target_os = "linux", target_os = "android"))]
 pub fn load_self() -> Option<Vec<u8>> {
     use std::io;
 
     match io::fs::readlink(&Path::new("/proc/self/exe")) {
         Ok(path) => Some(path.into_vec()),
         Err(..) => None
     }
diff --git a/src/libstd/sys/unix/process.rs b/src/libstd/sys/unix/process.rs
index 1357bbd..46800d0 100644
--- a/src/libstd/sys/unix/process.rs
+++ b/src/libstd/sys/unix/process.rs
@@ -598,17 +598,18 @@ fn translate_status(status: c_int) -> ProcessExit {
         pub fn WIFEXITED(status: i32) -> bool { (status & 0xff) == 0 }
         pub fn WEXITSTATUS(status: i32) -> i32 { (status >> 8) & 0xff }
         pub fn WTERMSIG(status: i32) -> i32 { status & 0x7f }
     }
 
     #[cfg(any(target_os = "macos",
               target_os = "ios",
               target_os = "freebsd",
-              target_os = "dragonfly"))]
+              target_os = "dragonfly",
+              target_os = "bitrig"))]
     mod imp {
         pub fn WIFEXITED(status: i32) -> bool { (status & 0x7f) == 0 }
         pub fn WEXITSTATUS(status: i32) -> i32 { status >> 8 }
         pub fn WTERMSIG(status: i32) -> i32 { status & 0o177 }
     }
 
     if imp::WIFEXITED(status) {
         ExitStatus(imp::WEXITSTATUS(status) as int)
diff --git a/src/libstd/sys/unix/sync.rs b/src/libstd/sys/unix/sync.rs
index 1d8a59d..d93d7b8 100644
--- a/src/libstd/sys/unix/sync.rs
+++ b/src/libstd/sys/unix/sync.rs
@@ -39,17 +39,19 @@ extern {
     pub fn pthread_rwlock_destroy(lock: *mut pthread_rwlock_t) -> libc::c_int;
     pub fn pthread_rwlock_rdlock(lock: *mut pthread_rwlock_t) -> libc::c_int;
     pub fn pthread_rwlock_tryrdlock(lock: *mut pthread_rwlock_t) -> libc::c_int;
     pub fn pthread_rwlock_wrlock(lock: *mut pthread_rwlock_t) -> libc::c_int;
     pub fn pthread_rwlock_trywrlock(lock: *mut pthread_rwlock_t) -> libc::c_int;
     pub fn pthread_rwlock_unlock(lock: *mut pthread_rwlock_t) -> libc::c_int;
 }
 
-#[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+#[cfg(any(target_os = "freebsd",
+          target_os = "dragonfly",
+          target_os = "bitrig"))]
 mod os {
     use libc;
 
     pub type pthread_mutex_t = *mut libc::c_void;
     pub type pthread_cond_t = *mut libc::c_void;
     pub type pthread_rwlock_t = *mut libc::c_void;
 
     pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = 0 as *mut _;
diff --git a/src/libstd/time/mod.rs b/src/libstd/time/mod.rs
index d6c94f2..b10ee1a 100644
--- a/src/libstd/time/mod.rs
+++ b/src/libstd/time/mod.rs
@@ -63,17 +63,18 @@ fn precise_time_ns() -> u64 {
     }
 }
 
 #[cfg(all(unix, not(target_os = "macos"), not(target_os = "ios")))]
 mod imp {
     use libc::{c_int, timespec};
 
     // Apparently android provides this in some other library?
-    #[cfg(not(target_os = "android"))]
+    // Bitrig's RT extensions are in the C library, not a separate librt
+    #[cfg(not(any(target_os = "android", target_os = "bitrig")))]
     #[link(name = "rt")]
     extern {}
 
     extern {
         pub fn clock_gettime(clk_id: c_int, tp: *mut timespec) -> c_int;
     }
 
 }
diff --git a/src/libsyntax/abi.rs b/src/libsyntax/abi.rs
index 09235ee..99c3cb6 100644
--- a/src/libsyntax/abi.rs
+++ b/src/libsyntax/abi.rs
@@ -19,16 +19,17 @@ use std::fmt;
 pub enum Os {
     OsWindows,
     OsMacos,
     OsLinux,
     OsAndroid,
     OsFreebsd,
     OsiOS,
     OsDragonfly,
+    OsBitrig,
 }
 
 #[derive(PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Clone, Copy)]
 pub enum Abi {
     // NB: This ordering MUST match the AbiDatas array below.
     // (This is ensured by the test indices_are_correct().)
 
     // Single platform ABIs come first (`for_arch()` relies on this)
@@ -141,17 +142,18 @@ impl fmt::String for Os {
     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
         match *self {
             OsLinux => "linux".fmt(f),
             OsWindows => "windows".fmt(f),
             OsMacos => "macos".fmt(f),
             OsiOS => "ios".fmt(f),
             OsAndroid => "android".fmt(f),
             OsFreebsd => "freebsd".fmt(f),
-            OsDragonfly => "dragonfly".fmt(f)
+            OsDragonfly => "dragonfly".fmt(f),
+            OsBitrig => "bitrig".fmt(f)
         }
     }
 }
 
 #[allow(non_snake_case)]
 #[test]
 fn lookup_Rust() {
     let abi = lookup("Rust");
diff --git a/src/rt/arch/x86_64/morestack.S b/src/rt/arch/x86_64/morestack.S
index c82da57..cf2b9b9 100644
--- a/src/rt/arch/x86_64/morestack.S
+++ b/src/rt/arch/x86_64/morestack.S
@@ -10,23 +10,23 @@
 #if defined(__APPLE__)
 #define MORESTACK               ___morestack
 #else
 #define MORESTACK               __morestack
 #endif
 
 #if defined(__APPLE__)
 #define EXHAUSTED               _rust_stack_exhausted
-#elif defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__)
+#elif defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__) || defined(__Bitrig__)
 #define EXHAUSTED               rust_stack_exhausted@PLT
 #else
 #define EXHAUSTED               rust_stack_exhausted
 #endif
 
-#if defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__)
+#if defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__) || defined(__Bitrig__)
 	.hidden MORESTACK
 #else
 #if defined(__APPLE__)
 	.private_extern MORESTACK
 #endif
 #endif
 
 #ifdef __ELF__
diff --git a/src/rt/rust_builtin.c b/src/rt/rust_builtin.c
index 5dc07f8..1f2ca35 100644
--- a/src/rt/rust_builtin.c
+++ b/src/rt/rust_builtin.c
@@ -65,17 +65,17 @@ timegm(struct tm *tm)
 #endif
 
 #ifdef __APPLE__
 #if (TARGET_OS_IPHONE)
 extern char **environ;
 #endif
 #endif
 
-#if defined(__FreeBSD__) || defined(__linux__) || defined(__ANDROID__) || defined(__DragonFly__)
+#if defined(__FreeBSD__) || defined(__linux__) || defined(__ANDROID__) || defined(__DragonFly__) || (__Bitrig__)
 extern char **environ;
 #endif
 
 #if defined(__WIN32__)
 char**
 rust_env_pairs() {
     return 0;
 }
diff --git a/src/test/run-pass/dupe-first-attr.rc b/src/test/run-pass/dupe-first-attr.rc
index 30d6b93..eb66423 100644
--- a/src/test/run-pass/dupe-first-attr.rc
+++ b/src/test/run-pass/dupe-first-attr.rc
@@ -21,12 +21,15 @@ mod hello;
 mod hello;
 
 #[cfg(target_os = "freebsd")]
 mod hello;
 
 #[cfg(target_os = "dragonfly")]
 mod hello;
 
+#[cfg(target_os = "bitrig")]
+mod hello;
+
 #[cfg(target_os = "android")]
 mod hello;
 
 pub fn main() { }
diff --git a/src/test/run-pass/intrinsic-alignment.rs b/src/test/run-pass/intrinsic-alignment.rs
index 52fcaf5..915abf7 100644
--- a/src/test/run-pass/intrinsic-alignment.rs
+++ b/src/test/run-pass/intrinsic-alignment.rs
@@ -36,16 +36,28 @@ mod m {
     pub fn main() {
         unsafe {
             assert_eq!(::rusti::pref_align_of::<u64>(), 8u);
             assert_eq!(::rusti::min_align_of::<u64>(), 8u);
         }
     }
 }
 
+#[cfg(target_os = "bitrig")]
+mod m {
+    #[main]
+    #[cfg(target_arch = "x86_64")]
+    pub fn main() {
+        unsafe {
+            assert_eq!(::rusti::pref_align_of::<u64>(), 8u);
+            assert_eq!(::rusti::min_align_of::<u64>(), 8u);
+        }
+    }
+}
+
 #[cfg(target_os = "windows")]
 mod m {
     #[main]
     #[cfg(target_arch = "x86")]
     pub fn main() {
         unsafe {
             assert_eq!(::rusti::pref_align_of::<u64>(), 8u);
             assert_eq!(::rusti::min_align_of::<u64>(), 8u);
diff --git a/src/test/run-pass/lang-item-public.rs b/src/test/run-pass/lang-item-public.rs
index 81774c7..d4c85c4 100644
--- a/src/test/run-pass/lang-item-public.rs
+++ b/src/test/run-pass/lang-item-public.rs
@@ -32,16 +32,20 @@ extern {}
 #[cfg(target_os = "freebsd")]
 #[link(name = "c")]
 extern {}
 
 #[cfg(target_os = "dragonfly")]
 #[link(name = "c")]
 extern {}
 
+#[cfg(target_os = "bitrig")]
+#[link(name = "c")]
+extern {}
+
 #[cfg(target_os = "macos")]
 #[link(name = "System")]
 extern {}
 
 #[start]
 fn main(_: int, _: *const *const u8) -> int {
     1 % 1
 }
diff --git a/src/test/run-pass/out-of-stack-new-thread-no-split.rs b/src/test/run-pass/out-of-stack-new-thread-no-split.rs
index ce6604d..190ed93 100644
--- a/src/test/run-pass/out-of-stack-new-thread-no-split.rs
+++ b/src/test/run-pass/out-of-stack-new-thread-no-split.rs
@@ -7,16 +7,17 @@
 // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
 // option. This file may not be copied, modified, or distributed
 // except according to those terms.
 
 //ignore-android
 //ignore-freebsd
 //ignore-ios
 //ignore-dragonfly
+//ignore-bitrig
 
 #![feature(asm)]
 
 use std::io::process::Command;
 use std::os;
 use std::thread::Thread;
 
 // lifted from the test module
diff --git a/src/test/run-pass/out-of-stack-no-split.rs b/src/test/run-pass/out-of-stack-no-split.rs
index 7992677..5054dbb 100644
--- a/src/test/run-pass/out-of-stack-no-split.rs
+++ b/src/test/run-pass/out-of-stack-no-split.rs
@@ -8,16 +8,17 @@
 // option. This file may not be copied, modified, or distributed
 // except according to those terms.
 
 //ignore-android
 //ignore-linux
 //ignore-freebsd
 //ignore-ios
 //ignore-dragonfly
+//ignore-bitrig
 
 #![feature(asm)]
 
 use std::io::process::Command;
 use std::os;
 
 // lifted from the test module
 // Inlining to avoid llvm turning the recursive functions into tail calls,
diff --git a/src/test/run-pass/rec-align-u64.rs b/src/test/run-pass/rec-align-u64.rs
index 2794154..da88880 100644
--- a/src/test/run-pass/rec-align-u64.rs
+++ b/src/test/run-pass/rec-align-u64.rs
@@ -49,16 +49,25 @@ mod m {
 
     #[cfg(any(target_arch = "x86_64", target_arch = "arm", target_arch = "aarch64"))]
     pub mod m {
         pub fn align() -> uint { 8u }
         pub fn size() -> uint { 16u }
     }
 }
 
+#[cfg(target_os = "bitrig")]
+mod m {
+    #[cfg(target_arch = "x86_64")]
+    pub mod m {
+        pub fn align() -> uint { 8u }
+        pub fn size() -> uint { 16u }
+    }
+}
+
 #[cfg(target_os = "windows")]
 mod m {
     #[cfg(target_arch = "x86")]
     pub mod m {
         pub fn align() -> uint { 8u }
         pub fn size() -> uint { 16u }
     }
 
diff --git a/src/test/run-pass/x86stdcall.rs b/src/test/run-pass/x86stdcall.rs
index 15d1852..13cab11 100644
--- a/src/test/run-pass/x86stdcall.rs
+++ b/src/test/run-pass/x86stdcall.rs
@@ -29,10 +29,11 @@ pub fn main() {
         assert_eq!(expected, actual);
     }
 }
 
 #[cfg(any(target_os = "macos",
           target_os = "linux",
           target_os = "freebsd",
           target_os = "dragonfly",
+          target_os = "bitrig",
           target_os = "android"))]
 pub fn main() { }
