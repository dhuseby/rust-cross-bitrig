diff --git a/lib/librthread/tcb.h b/lib/librthread/tcb.h
index 23e5cd9..5c4fb5f 100644
--- a/lib/librthread/tcb.h
+++ b/lib/librthread/tcb.h
@@ -69,56 +69,60 @@ void	__set_tcb(void *);
 /*
  * Small TCB, with TLS data after the TCB.
  * Errno pointer stored in struct pthread
  */
 
 struct thread_control_block {
 	void	*tcb_dtv;		/* internal to the runtime linker */
 	struct	pthread *tcb_thread;
+	void *tcb_segstack; /* used for segmented stacks */
 };
 
 #ifndef THREAD_ERRNOPTR_OFFSET
 # define THREAD_ERRNOPTR_OFFSET	offsetof(struct pthread, errno_ptr)
 #endif
 #define __ERRNOPTR(thread)	\
 	(((int **)(thread))[THREAD_ERRNOPTR_OFFSET / sizeof(int *)])
 #define TCB_ERRNOPTR()	\
 	__ERRNOPTR(TCB_THREAD())
 #define	TCB_INIT(tcb, thread, errnoptr)			\
 	do {						\
 		(tcb)->tcb_thread = (thread);		\
 		__ERRNOPTR(thread) = (errnoptr);	\
+		(tcb)->tcb_segstack = NULL; \
 	} while (0)
 
 
 #elif TLS_VARIANT == 2
 /*
  * Large TCB, with TLS data before the TCB (i.e., negative offsets)
  * Errno pointer stored in the TCB
  */
 
 struct thread_control_block {
 	struct	thread_control_block *__tcb_self;
 	void	*tcb_dtv;		/* internal to the runtime linker */
 	struct	pthread *tcb_thread;
 	int	*__tcb_errno;
+	void *tcb_segstack; /* used for segmented stacks */
 };
 
 #ifdef TCB_GET_MEMBER
 #define TCB_ERRNOPTR()	((int *)TCB_GET_MEMBER(__tcb_errno))
 #else
 #define TCB_ERRNOPTR()	\
 		(((struct thread_control_block *)__get_tcb())->__tcb_errno)
 #endif
 #define	TCB_INIT(tcb, thread, errnoptr)			\
 	do {						\
 		(tcb)->__tcb_self = (tcb);		\
 		(tcb)->tcb_thread = (thread);		\
 		(tcb)->__tcb_errno = (errnoptr);	\
+		(tcb)->tcb_segstack = NULL; \
 	} while (0)
 
 
 #else
 # error "unknown TLS variant"
 #endif
 
 
diff --git a/libexec/ld.so/Makefile b/libexec/ld.so/Makefile
index 9db2699..8135517 100644
--- a/libexec/ld.so/Makefile
+++ b/libexec/ld.so/Makefile
@@ -19,16 +19,17 @@ SRCS+=	malloc.c reallocarray.c library.c tls.c
 
 .include "${.CURDIR}/${MACHINE_CPU}/Makefile.inc"
 .PATH:	${.CURDIR}/${MACHINE_CPU}
 
 DEBUG?=	-g
 CFLAGS += -Wall -fno-builtin -Werror
 CFLAGS += -I${.CURDIR} -I${.CURDIR}/${MACHINE_CPU} \
 	-Dstrsep=_dl_strsep -Dstrlcat=_dl_strlcat -Dstrlen=_dl_strlen
+CFLAGS += -DRTLD_NO_WXORX
 CDIAGFLAGS=
 INSTALL_STRIP=
 
 ELF_LDFLAGS+=--shared -Bsymbolic --no-undefined
 
 candidate=	$(PROG).test
 CLEANFILES+=	${candidate}
 .if ${HOSTCC} == ${CC}
diff --git a/libexec/ld.so/tls.h b/libexec/ld.so/tls.h
index 92e26b5..3d69c33 100644
--- a/libexec/ld.so/tls.h
+++ b/libexec/ld.so/tls.h
@@ -22,17 +22,19 @@ typedef struct {
 	unsigned long int ti_offset;
 } tls_index;
 
 /* copied from librthread/tcb.h */
 #if TLS_VARIANT == 1
 struct thread_control_block {
 	void	*tcb_dtv;               /* internal to the runtime linker */
 	struct	pthread *tcb_thread;
+	void	*tcb_segstack; /* used for segmented stacks */
 };
 #elif TLS_VARIANT == 2
 struct thread_control_block {
-        struct	thread_control_block *__tcb_self;
-        void	*tcb_dtv;               /* internal to the runtime linker */
-        struct	pthread *tcb_thread;
-        int	*__tcb_errno;
+	struct	thread_control_block *__tcb_self;
+	void	*tcb_dtv;               /* internal to the runtime linker */
+	struct	pthread *tcb_thread;
+	int	*__tcb_errno;
+	void	*tcb_segstack; /* used for segmented stacks */
 };
 #endif
